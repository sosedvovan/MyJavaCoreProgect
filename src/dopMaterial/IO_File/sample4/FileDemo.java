package dopMaterial.IO_File.sample4;

//пример поиска в оределенной директории с использ фильтра
import java.io.*;

public class FileDemo {

    public static void findFiles(File file, FileFilter filter,
                                 PrintStream output) throws IOException {
        if (file.isDirectory()) {//если это директория, а не файл выполним:
            File[] list = file.listFiles();//в массив заносим имена отфильтрованных файлов и их пути
            for (int i = list.length; --i >= 0; ) {//итерируемся от конца массива к началу
                findFiles(list[i], filter, output);//рекурсия для вывода массива
            }
        } else {//иначе, если это файл- напечатаем его путь
            if (filter.accept(file))
                output.println("\t" + file.getCanonicalPath());
        }
    }

    public static void main(String[] args) {

        //получим реализацию абстракта функционального интерфейса FileFilter
        class NameFilter implements FileFilter {
            private String mask;

            NameFilter(String mask) {
                this.mask = mask;
            }

            //в абстракт попадает файл, а выходит буль
            public boolean accept(File file) {
                return (file.getName().indexOf(mask) != -1) ? true : false;
            }
        }
        File pathFile = new File(".");//"." указывает на главную папку этого проекта
        String filterString = ".java";//задали фильтр
        try {
            //получили ссылку на реализацию абстракта
            FileFilter filter = new NameFilter(filterString);
            //запускаем статик метод фильтрации и рекурсивного вывода:
            findFiles(pathFile, filter, System.out);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("work finished");
    }
}

/**
 * Работа с файловой системой
 * Класс File
 *
 * Если классы потоков осуществляют реальную запись и чтение данных, то класс File – это вспомогательный инструмент,
 * призванный обеспечить работу с файлами и каталогами.
 *
 * Объект класса File является абстрактным представлением файла и пути к нему. Он устанавливает только соответствие с
 * ним, при этом для создания объекта неважно, существует ли такой файл на диске. После создания можно выполнить проверку,
 * вызвав метод exists, который возвращает значение true, если файл существует. Создание или удаление объекта класса File
 * никоим образом не отображается на реальных файлах. Для работы с содержимым файла можно получить экземпляры FileI/OStream.
 *
 * Объект File может указывать на каталог (узнать это можно путем вызова метода isDirectory ). Метод list возвращает
 * список имен (массив String ) содержащихся в нем файлов (если объект File не указывает на каталог – будет возвращен null ).
 *
 * Следующий пример демонстрирует использование объектов класса File
 *
 * При выполнении этой программы на экран будут выведены названия (в каноническом виде) всех файлов, с расширением .java, содержащихся в текущем каталоге и всех его подкаталогах.
 *
 * Для определения того, что файл имеет расширение .java, использовался интерфейс FileFilter с реализацией в виде внутреннего класса NameFilter. Интерфейс FileFilter определяет только один метод accept, возвращающий значение, определяющее, попадает ли переданный файл в условия фильтрации. Помимо этого интерфейса, существует еще одна разновидность интерфейса фильтра – FilenameFilter, где метод accept определен несколько иначе: он принимает не объект файла к проверке, а объект File, указывающий на каталог, где находится файл для проверки, и строку его названия. Для проверки совпадения, с учетом регулярных выражений, нужно соответствующим образом реализовать метод accept. В конкретном приведенном примере можно было обойтись и без использования интерфейсов FileFilter или FilenameFilter. На практике их можно использовать для вызова методов list объектов File – в этих случаях будут возвращены файлы с учетом фильтра.
 *
 * Также класс File предоставляет возможность получения некоторой информации о файле.
 *
 *     Методы canRead и canWrite – возвращается boolean значение, можно ли будет приложению производить чтение и изменение содержимого из файла, соответственно.
 *     getName – возвращает строку – имя файла (или каталога).
 *     getParent, getParentName – возвращают каталог, где файл находится в виде объекта и строки названия File, соответственно.
 *     getPath – возвращает путь к файлу (при этом в строку преобразуется абстрактный путь, на который указывает объект File ).
 *     isAbsolutely – возвращает boolean значение, является ли абсолютным путь, которым указан файл. Определение, является ли путь абсолютным, зависит от системы, где запущена Java-машина. Так, для Windows абсолютный путь начинается с указания диска, либо символом '\'. Для Unix абсолютный путь начинается символом '/'.
 *     isDirectory, isFile – возвращает boolean значение, указывает ли объект на каталог либо файл, соответственно.
 *     isHidden – возвращает boolean значение, указывает ли объект на скрытый файл.
 *     lastModified – дата последнего изменения.
 *     length – длина файла в байтах.
 *
 * Также можно изменить некоторые свойства файла – методы setReadOnly, setLastModified, назначение которых очевидно из названия.
 * Если нужно создать файл на диске, это позволяют сделать методы createNewFile, mkDir, mkDirs. Соответственно, createNewFile
 * создает пустой файл (если таковой еще не существует), mkDir создает каталог, если для него все родительские уже существуют,
 * а mkDirs создаст каталог вместе со всеми необходимыми родительскими.
 *
 * Файл можно и удалить – для этого предназначены методы delete и deleteOnExit. При вызове метода delete файл будет удален
 * сразу же, а при вызове deleteOnExit по окончании работы Java-машины (только при корректном завершении работы) отменить
 * запрос уже невозможно.
 *
 * Таким образом, класс File дает возможность достаточно полного управления файловой системой.
 * Класс RandomAccessFile
 *
 * Этот класс реализует сразу два интерфейса – DataInput и DataOutput – следовательно, может производить запись и чтение
 * всех примитивных типов Java. Эти операции, как следует из названия, производятся с файлом. При этом их можно производить
 * поочередно, произвольным образом перемещаясь по файлу с помощью вызова метода seek(long) (переводит на указанную позицию в файле).
 * Узнать текущее положение указателя в файле можно вызовом метода getFilePointer.
 *
 * При создании объекта этого класса конструктору в качестве параметров нужно передать два параметра: файл и режим работы.
 * Файл, с которым будет проводиться работа, указывается либо с помощью String – название файла, либо объектом File, ему
 * соответствующим. Режим работы ( mode ) – представляет собой строку либо "r" (только чтение), либо "rw" (чтение и запись).
 * Попытка открыть несуществующий файл только на чтение приведет к исключению FileNotFoundException. При открытии на чтение
 * и запись он будет незамедлительно создан (или же будет брошено исключение FileNotFoundException, если это невозможно осуществить).
 *
 * После создания объекта RandomAccessFile можно воспользоваться методами интерфейсов DataInput и DataOutput для проведения
 * с файлом операций считывания и записи. По окончании работы с файлом его следует закрыть, вызвав метод close.
 * Заключение
 *
 * В данной лекции вы познакомились с таким важным понятием, как потоки данных ( stream ). Потоки являются очень эффективным
 * способом решения задач, связанных с передачей и получением данных, независимо от особенностей используемых устройств
 * ввода/вывода. Как вы теперь знаете, именно в пакете java.io содержатся стандартные классы, решающие задачи обмена данными
 * в самых различных форматах.
 *
 * Были описаны базовые классы байтовых потоков InputStream и OutputStream, а также символьных потоков Reader и Writer.
 * Все классы потоков явным или неявным образом наследуются от них. Краткий обзор показал, для чего предназначен каждый
 * класс, как с ним работать, какие классы не рекомендованы к использованию. Изучено, как передавать в потоки значения
 * примитивных типов Java. Особое внимание было уделено операциям с объектами, для которых существует специальный механизм
 * сериализации.
 *
 * Наконец, были описаны классы для работы с файловой системой – File и RandomAccessFile.
 */
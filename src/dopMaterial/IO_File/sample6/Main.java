package dopMaterial.IO_File.sample6;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {

        //экземпляр класса файл ассоциированный
        File file = new File("save.txt");
        //если по указанному адрессу есть такой файл,
        //то все действия найдут отображение в файловой системе

        //проверим- существует ли такой файл в натуре
        System.out.println(file.exists());
        //---------------------------------------------------
        //СОЗДАДИМ ФАЙЛ
        File file2 = new File("save2.txt");//нет такого файла в натуре
        //тк создание ассоциированного объекта не приводит к созданию файла
        System.out.println(file2.exists());//проверили что нет
        try {
            file2.createNewFile();//создали его
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(file2.exists());//проверили, что создали
        //--------------------------------------------------------------
        //СОЗДАДИМ ПАПКУ
        File folder = new File("A");
        folder.mkdirs();
        //---------------------------------------------------------------
        //СОЗДАДИМ ФАЙЛ В ОПРЕДЕЛЕННОЙ ПАПКЕ ИСП ПЕРЕГРУЖЕННЫЙ КОНСТРУКТОР
        File fileThree = new File(folder, "b.txt");
        try {
            fileThree.createNewFile();//создали его
        } catch (IOException e) {
            e.printStackTrace();
        }
        //-------------------------------------------------------------------
        //УДАЛЕНИЕ(ЕСЛИ КАТАЛОГ НЕ ПУСТОЙ, ОН НЕ УДАЛИТСЯ - это св-во операц сист)
        fileThree.delete();//сначала удаляем файл в каталоге
        folder.delete();//потом удаляем сам каталог

        //рекурсивно удаляют произвольн уровень вложенности

        //--------------------------------------------------------------------

        //list, listFile- вернут массивы Стрингов и файлов соответственно
        //в поданном в аргументы каталоге

        //каталогов нет- это ссылки, прекрепленные к файлам

        //----------------------------------------------------------
        //ассоциируемся с каталогом, а не с файлом:
        File file3 = new File(".");
        //"." - ссылка на каталог, из которого происх запрос,те из проекта

        //получим массив с файлами в этом каталоге
        File[] fileArrais = file3.listFiles();
        for (File f : fileArrais) {//пройдем по массиву
            long filesize = f.length();//получим размер в байтах каждого файла или каталога
            String type = (f.isFile()) ? "File" : "Folder";//узнаем- файл это или каталог
            //далее выведем имя, тип и размер:
            System.out.println(f.getName() + " " + type + " " + filesize);

            //увидим, что папка может быть 0 байтов, хоть и не пустая
        }

        //----------------------------------------------------------------
        //СОРТИРОВКА ФАЙЛОВ В КАТАЛОГЕ
        //метод listFiles() -перегружен, если вторым параметром подать
        //объект класса реализующий функциональный  интерфейс FileFilter (FilenameFilter)
        //тогда врезультирующий список попадут только прошедшие фильтрацию - true
        //абсракт, кот надо реализовать: boolean accept (File file);

        //---------------------------------------------------------------------
        //Проверим работу нашего статического метода(см ниже) копирования файлов:
        //в качестве источнока зададим реально существующий файл
        File is = new File("D:\\piterson_12-pravil-zhizni-protivoyadie-ot-haosa_nntg6q_544905.pdf");
        //приемник ассоциируем с объектом File out виртуальный файл. Он будет создан самим потоком (вручную можно не создавать)
        File out = new File("D:\\MyCopyTest.pdf");
        try {//вызовем наш метод в блоке try, тк сами в методе создали ексепшен
            fileCopy(is, out);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //-------------------------------------------------------------------------


    }


    //метод копирования файлов/ в аргументах входящий(источник) и исходящий(в него копируем) файлы
    public static void fileCopy(File in, File out) throws IOException {
        byte[] buffer = new byte[1024 * 1024];//буферный массив, размером с мегабайт
        int readByte = 0;//переменная для кол-ва реально вычитанных байт
        //в блоке трай ресурсес объявим 2 файловых потока для чтения и записи:
        try (FileInputStream fis = new FileInputStream(in);
             FileOutputStream fos = new FileOutputStream(out);) {

            //в  цикле с условием: пока переменная readByte, равная результату работы
            //FileInputStream fis(сколько он вычитает из источника) > 0
            //что делать: писать в приемник FileOutputStream fos. чтописать: содержимое буфера
            //от 0 до реально считанных байт
            for (; (readByte = fis.read(buffer)) > 0; ){//fis.read(buffer): вычитываем из источника fis в buffer
                                                        //те пока хоть что-то считываелось, выполняется след строчка:
                fos.write(buffer, 0, readByte);//записываем в приемник fos копию массива buffer, но не всего,
                                                   //а с 0-ого по реально вычитанных байт

                //замечание к методу read()- если что-то считалось, то вернет цифру равную индексу крайнего
                //вычитанного байта в буфере(это в нашем случае, а обычно-это кол-во вычитанных байт),
                //если ничего не считает, вернет -1 (этот метод пришел из Си+)
            }

        } catch (IOException e) {//исключение поймали(если скопировать не удалось)
            throw e;//и прокинули вверх в сигнатуру метода
        }

    }
}

/**
 * Stream API.
 * Часть 10. Примитивные специализации Stream
 * <p>
 * В Java существует несколько примитивных специализаций интерфейса Stream. Это интерфейсы
 * IntStream, LongStream, DoubleStream. Эти интерфейсы предназначены для работы с примитивными
 * типами данных (int, long, double соответственно). Основная причина их введения это повышение
 * производительности (работа с примитивными типами быстрее работа с классами оболочками). Для
 * примитивной специализации определенны такие же терминальные и промежуточные методы как и
 * для Stream.
 * <p>
 * Способы создания примитивных потоков
 * <p>
 * Статический метод of(..)
 * Создаст поток на основе перечисления элементов
 * <p>
 * Статический метод of(..)
 * Создаст поток на основе массива
 * <p>
 * Статический метод range(start, end)
 * Создаст целочисленный поток, значений от start до end (не включает
 * последнее значение). Для DoubleStream этот метод отсутствует.
 * <p>
 * Статический метод rangeClosed(start, end) Создаст целочисленный поток, значений от start до end (включает
 * последнее значение). Для DoubleStream этот метод отсутствует.
 * <p>
 * ***********************************************************************************************************
 * Создание потока с помощью Builder
 * Для создания примитивных специализаций Stream можно использовать Builder (строитель).
 * Builder обладает несколькими фазами: фазой добавления элементов, и фазой построения потока.
 * Получить Builder, специфичный для каждого типа потока, можно вызвав статический метод builder().
 * Сам Builder описан как вложенный интерфейс. Так например для IntStream это вложенный интерфейс
 * IntStream.Builder.
 * <p>
 * Методы Builder на примере IntStream.Builder
 * <p>
 * void accept (int t)
 * Добавляет элемент для построения потока. Фаза сборки.
 * <p>
 * default IntStream.Builder add (int t)
 * Добавляет элемент для построения, при этом позволяя
 * добавление элементов в цепочку. Фаза сборки.
 * <p>
 * IntStream build()
 * Вернет собранный поток. Фаза построения потока.
 * Фаза сборки элементов протекает от момента создания Builder и до первого вызова метода
 * build(). Попытка вызвать методы accert и add после начала фазы сборки приведут к генерации
 * исключения IllegalStateException.
 * <p>
 * Builder для других типов потока идентичен, различие только в типе используемых примитивных
 * типов.
 * ************************************************************************************************************
 *                        Возможность преобразования потоков
 *
 * Для примитивных специализаций Stream существует особые промежуточные методы по
 * преобразованию одного типа потока в другой. Преобразование возможно только по восходящему
 * преобразованию.
 * IntStream -> LongStream -> DoubleStream
 *
 * Метод, Описание:
 * asIntStream() Преобразование в IntStream
 *
 * asLongStream() Преобразование в LongStream
 *
 * asDoubleStream() Преобразование в DoubleStream
 * ***************************************************************************************************************
 *                            Характерные терминальные методы
 * Метод, Описание:
 * OptionalDouble average() Вычисление среднего
 *
 * OptionalInt max() Вернет максимум
 *
 * OptionalInt min() Вернет минимум
 *
 * IntSummaryStatistics summaryStatistics() Вернет статистику
 *
 * Метод average() одинаков для всех потоков, методы max, min, summaryStatistic возвращают
 * значения соответствующие типу потока.
 */

package javaCore34.StreamAPI_10ПримитивныеСпециализацииStream.sample1;

import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.function.IntPredicate;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main {

    public static void main(String[] args) {

        //Todo Пример использования метода of. В примере создаются реализации IntStream на основе набора чисел и массива целых чисел.

        //получаем стрим
        IntStream is1 = IntStream.of(1, 2, 3, 4, 5, 6);

        //добавляем фильтр в стрим и терминальный метод
        is1.filter(a -> a > 2).forEach(a -> System.out.println(a));

        is1.close();//можно и без этого

        IntStream is2 = IntStream.of(new int[]{1, 2, 3, 4});

        is2.filter(a -> a % 2 == 0).forEach(a -> System.out.println(a));

        //----------------------------------------------------------------------------------------------------------

        //Todo Пример применения метода range(start, end).В примере создается IntStream на основании диапазона от 2 до 100 (100 не включается).
        // IntPredicate реализован как проверка числа на простоту. Таким образом мы получим ряд целых чисел от 2 до 99

        //получим реализацию предиката
        IntPredicate iPred = n -> {
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    return false;
                }
            }
            return true;
        };

        IntStream is = IntStream.range(2, 100);//то же самое если IntStream.of(2, 3,......,100)

        is.filter(iPred).forEach(a -> System.out.print(a + " "));

        //-----------------------------------------------------------------------------------------------------------

        //Todo Пример использования Builder. В примере создается Builder. На этапе сборки в него добавляются элементы равные хеш кодам
        // строк из массива. Вызов метода build() запускает фазу построения потока и возвращает поток.

        //Имеется массив строк
        String[] languages = new String[]{"Java", "Fortran", "Python"};

        IntStream.Builder builder = IntStream.builder();//Создание Builder. это еще не поток

        //Добавление элементов в Builder(добавляем hashCode'ы полученные на основе строк)
        for (String element : languages) {
            builder.accept(element.hashCode());//метод accept() видимо добавляет элементы в поток
        }

        //получим стрим
        //Построение потока с использованием Builder
        IntStream is3 = builder.build();

        is3.forEach(a -> System.out.println(a));

        //---------------------------------------------------------------------------------------------------------

        //Todo Пример преобразования потоков. В примере создается IntStream после чего она преобразуется в DoubleStream с использованием
        // метода asDoubleStream(). Суммируем заданный диапазон чисел.

        IntStream is4 = IntStream.range(1, 100);//Создание IntStream на основе диапазона чисел

        Double sum = is4.asDoubleStream().sum();//Преобразование в DoubleStream и вызов терминального метода sum

        System.out.println(sum);

        //---------------------------------------------------------------------------------------------------------------

        //Todo Преобразование в Stream.Возможна упаковка примитивной специализации в Stream. Для этого используется метод
        // boxed().

        //rangeClosed возвращает
        // поток (от1 до 10 включительно)
        IntStream is5 = IntStream.rangeClosed(1, 10);

        //is5.boxed() упакует объект IntStream is5 в поток  (boxed() возвращает уже поток)
        List<Integer> result = is5.boxed().collect(Collectors.toList());//is5.boxed() это Упаковка в Stream перед collect зачем то нужна

        System.out.println(result);

        //-----------------------------------------------------------------------------------------------------------

        //Todo Пример применения метода summaryStatistics

        IntStream is6 = IntStream.of(new int[] { 0, -2, 5, 10, 3 });

        IntSummaryStatistics stat = is6.summaryStatistics();//Получение объекта статистики на основе элементов потока

        System.out.println("Max = " + stat.getMax());
        System.out.println("Min = " + stat.getMin());
        System.out.println("Average = " + stat.getAverage());
        System.out.println("Sum = " + stat.getSum());



    }


}


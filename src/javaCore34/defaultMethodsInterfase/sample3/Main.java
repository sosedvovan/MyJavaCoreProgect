package javaCore34.defaultMethodsInterfase.sample3;

public class Main {
    public static void main(String[] args) {
        C classC = new C("Hello");
        A interfaceA = classC;
        B interfaceB = classC;
        System.out.println(classC.getMessage());//Hello Hello
        System.out.println(interfaceA.getMessage());//Hello Hello
        System.out.println(interfaceB.getMessage());//Hello Hello
    }
}

/**
 * смотрим на диаграмму sample3 с отображением методов
 * видим что класс С не переопределяет метод getMessage() доставшийся ему от :
 * ----   extends RealizationA (это класс)  и одновременно от     implements B  (это интерфейс)   ----
 * Вопрос: объект ---classC.getMessage()---- какой именно метод вызовет -из класса родителя или интерфейса родителя?
 * Ответ: из класса родителя -- это такое правило в Java
 *
 *
 *
 *Как видно, реализации методов находятся на одинаковом уровне наследования, в
 * таком случае всегда выполняется метод из класса. Общее правило таково —
 * предпочтение всегда отдается методу, реализованному в классе.
 */

/**
 * Проблема множественного наследования default методов:
 *
 * При наследовании классом нескольких интерфейсов с default методами одинаковой
 * сигнатуры (default methods)без реализации этого метода в классе) возникает ошибка множественного
 * наследования.
 *
 * ПРОБЛЕМА РОМБА:
 * Внимание !! Ошибка, связанная с множественным наследованием, появляется
 * только в случае наследования двух и более интерфейсов с одинаковыми default
 * методами. Если в иерархии наследования есть класс, содержащий реализацию
 * default метода, то всегда будет вызван метод класса.
 *
 * ---public class C implements A, B {...} здесь будет ошибка компиляции тк в интерфейсе А и В
 * есть одинаковые default методы и class C не знает какой именно выполнять
 *
 * Решение:
 * Для решения проблемы множественного наследования от интерфейсов с
 * одинаковыми default методами нужно реализовать в самом классе default метод. Если
 * при реализации default метода нужно все равно вызвать один из default методов
 * интерфейсов, следует использовать синтаксис.
 * InterfaceName.super.methodName(args..)
 *
 * в коде выглядит так: в классе С реализуем:
 *
 * @Override
 * public String getMessage() {  //Реализация default метода интерфейсов
 * return A.super.getMessage();   //Явный вызов default метода интерфейса А
 * }
 *
 *
 */
package javaCore34.сomparable.sample1;

//Проверка на корректность реализации Comparable:
public class Main {

    public static void main(String[] args) {

        //Объекты для проверки (здесь мы не добавляем объекты в массив, а просто сраниваем их друг с другом)
        Cat a = new Cat("Umka", 12);
        Cat b = new Cat("Luska", 5);
        Cat c = new Cat("Kuzia", 2);
        Cat d = new Cat("Umka", 12);
        Cat e = new Cat("Barsic", 12);

        //Проверка на корректность реализации Comparable
        //Для приведенной реализации выполним ряд необходимых проверок. Как можно
        //видеть выполняются такие свойства как:
        //● Антисимметричность
        //● Транзитивность
        //● Правило равенства знаков
        System.out.println(sgn(a.compareTo(b)) == -sgn(b.compareTo(a))); //true
        System.out.println((a.compareTo(b) > 0 && b.compareTo(c) > 0) && a.compareTo(c) > 0); // true
        System.out.println(a.compareTo(d) == 0 && (sgn(a.compareTo(c)) == sgn(d.compareTo(c)))); // true

        //Теперь проверка на согласованность с equals:
        System.out.println(a.equals(d) == true && a.compareTo(d) == 0);//true
        System.out.println(a.equals(b) == false && a.compareTo(b) != 0);//true
        System.out.println(a.equals(e) == false && a.compareTo(e) != 0);//true

        //Благодаря тому, что при сравнении было учтена реализация equals то полученное
        //отношение естественного порядка согласованно с отношением эквивалентности.

    }

    //Метод для проверки знака
    public static int sgn(int x) {
        if (x > 0) {
            return 1;
        } else if (x < 0) {
            return -1;
        }
        return 0;
    }
}

/**
 *                               Функциональный интерфейс Comparable:
 *
 * Comparable<T> - функциональный интерфейс. Этот интерфейс устанавливает
 * отношение полного порядка для объектов класса, который его реализует. Это отношение
 * порядка называется естественным порядком (natural ordering), а метод compareTo
 * называется его естественным методом сравнения (natural comparison method).
 * Используется для сравнения объектов между собой, в задачах сортировки и поисках
 * минимального и максимального элемента в последовательностях.
 *
 * Отношение полного порядка
 * Любое бинарное отношение на множестве называется отношением полного порядка
 * если оно обладает следующими характеристиками:
 * Рефлексивность            ∀a∈X : aRa
 * Антисимметричность        ∀a , b∈X :aRb∧bRa⇒a=b
 * Транзитивность            ∀a , b, c∈X : aRb∧bRc⇒aRc
 *                           ∀a , b∈X :aRb∨bRa
 *                           ∀Y⊂X ∃a∈Y ∀b∈Y : aRb
 *
 * Замечания к определению Comparable
 * Желательно что бы отношение естественного порядка было согласованно с
 * отношением эквивалентности. Т.е. для двух объектов a и b:
 * 1)a.equals(b)==true → a.compareTo(b)==0
 * 2)a.compareTo(b) ==0 →a.equals(b)==true
 * 3)a.compareTo(b) !=0 →a.equals(b)==false
 * Замечание. Если параметр метода compareTo() равен null то должно быть
 * возбужденно исключение NullPointerException, даже если equals при этом возвращает
 * false. Большинство классов стандартной библиотеки (реализующих Comparable)
 * используют согласованное определение.
 *
 *                      Причины необходимости согласования отношения
 *                      естественного порядка и отношения эквивалентности:
 * Некоторые реализации Collection используют для определения порядка хранения
 * элементов отношение естественного порядка (например реализации SortedSet). Но для
 * случая когда a.equals(b)==false, a.compareTo(b)==0 вы сможете добавить элемент b в
 * такую коллекцию, но после этого уже не сможете добавить a, так как с точки зрения
 * отношения естественного порядка они равны. Но они не эквиваленты, что противоречит
 * самой идее множеств.
 *
 *                       Абстрактный метод интерфейса Comparable<T>:
 *      Метод                   Описание
 * int compareTo(T o)           Выполняет сравнение текущего объекта с объектом по ссылке используемой в
 *                              качестве параметра. Если текущий объект больше (по выбранному вами
 *                              критерию) то необходимо вернуть положительное число. В случае когда
 *                              текущий объект меньше, то отрицательное. Ноль стоит вернуть в случае
 *                              равенства этих объектов.
 *
 *  В качестве абстрактного метода интерфейса Comparable<T> выступает метод int compareTo(T o).
 * Его реализация должна вернуть положительное число (любое) если
 * текущий объект по выбранному вами критерию больше объекта по ссылке o,
 * отрицательное число если текущий меньше o и 0 в случае их равенства.
 * Желательно что бы для любых параметров (a,b,c) выполнялись такие соотношения:
 * 1) sgn(a.compareTo(b) == - sgn(b.compareTo(a))
 * 2) a.compareTo(b)>0 && b.compareTo(c)>0 следует a.compareTo(c)>0
 * 3) a.compareTo(b)==0 следует sgn(a.compare(c))==sgn(b.compareTo(c)) для всех c.
 * 4) Если a.compareTo(b) генерирует исключение, то и b.compareTo(a) генерирует такое же
 * исключение.
 * Функция определяющая знак аргумента x               ( 1, x>0)
 *                                        sgn( x)=     ( 0, x=0)
 *                                                     (−1, x<0)
 *
 */

/**
 *                                     Stream API
 *                                  Часть 1. Вступление
 *
 *                                    Stream API в Java
 * Stream API — новый механизм обработки данных в функциональном стиле впервые
 * появившийся в Java 8. Этот механизм позволяет упростить обработку данных. Чаще всего
 * этот механизм применяют к данным хранимым в структурах данных (массивах, списках,
 * множествах и т. д.) и в файлах. Но может быть применен практически к любому источнику
 * данных.
 *
 *                                  Понятие потока данных
 * Ключевым понятием Stream API является понятие потока (stream) данных. Поток
 * данных — возможность поочередного (или одновременного) получения элемента данных
 * для последующей обработки.
 * Stream является альтернативой итераторам. Итераторы (Iterator) представляют собой
 * способ внешнего итерирования по данным, в тоже время Stream способ внутреннего
 * итерирования.
 *
 * Iterator: hasNext() next() remove() над каждым элементом поочередно работают (внешняя итерация)
 * Stream: stream()-вошел в коллекцию, сделал всю работу и collect()-вышел с результатом (внутренняя итерация)
 *
 *                     В чем разница между ними
 * Разницей между внешней и внутренней итерацией с точки зрения программной
 * реализации являются интерфейсы лежащие в основе этих механизмов. Если для
 * внешней итерации используется Iterator<T>, то в основе внутренней итерации лежит
 * Spliterator<T>.
 * Таким образом в логической основе Stream API лежит интерфейс Spliterator и его
 * реализации. Его изучение будет проведено в более поздних лекциях.
 *
 *                        Как это реализовано с точки зрения кода
 * В Java 8 был добавлен интерфейс BaseStream<T, S extends BaseStream<T, S>> который
 * и служит базовым для Stream API. Именно в нем определенны методы для создания и
 * работы с потоками данных.
 * Эти методы можно разделить на две категории:
 * 1)Промежуточные (“intermediate”) — обрабатывают поступающие элементы и возвращают
 * stream. Промежуточных методов в цепочке обработки элементов может быть много.
 * 2)Терминальные (“terminal”) — обрабатывают элементы и завершают работу stream, так
 * что терминальный метод в цепочке может быть только один.
 *
 *                               Методы интерфейса BaseStream
 *   Метод             Описание
 * void close() Закрытие потока данных
 * boolean isParallel() Возвращает true если операции потока данных могут выполниться параллельно (в
 * терминальном методе)
 * Iterator<T> iterator() Возвращает итератор для элементов этого потока данных. Терминальный метод.
 * S onClose (Runnable closeHandler) Возвращает эквивалентный поток с дополнительным обработчиком закрытия
 * S parallel() Возвращает эквивалентный поток данных позволяющий параллельную обработку данных
 * S sequential() Возвращает эквивалентный поток данных в котором данные обрабатываются последовательно
 * Spliterator<T> spliterator() Возвращает сплитератор для потока данных. Терминальный метод.
 * S unordered() Возвращает эквивалентный поток данных в котором не сохраняется порядок следования
 * элементов который был использован в источнике данных
 *
 * Выводы из знакомства с StreamBase
 * Из предварительного знакомства с методами StreamBase можно сделать вывод что
 * потоки данных можно разделить на несколько категорий:
 * Потоки данных - Сохраняют порядок или Не сохраняют порядок
 * Потоки данных - Последовательные или Параллельные
 *
 *                 Как это реализовано с точки зрения кода
 * В Java 8 были введены интерфейсы Stream<T> (для работы с объектами) и IntStream,
 * LongStream, DoubleStream (для работы с примитивными типами) которые и отвечают за
 * методы предоставляемыми этим API. Данные интерфейсы являются наследниками
 * интерфейса BaseStream. В них описаны методы для обработки данных в функциональном
 * стиле. И эти методы также подразделяются на:
 * 1)Промежуточные (“intermediate”) — обрабатывают поступающие элементы и возвращают
 * stream. Промежуточных методов в цепочке обработки элементов может быть много.
 * 2)Терминальные (“terminal”) — обрабатывают элементы и завершают работу stream, так
 * что терминальный метод в цепочке может быть только один.
 *
 *                         Логика использования Stream
 *               указываем:           Источник данных
 *               далее идет           Промежуточный метод
 *               далее идет           Промежуточный метод
 *               далее идет           Промежуточный метод
 *               и завершает          Терминальный метод
 *
 *                         Сведения о потоках данных
 * Потоки данных это не хранилище данных. Потоки это способ получения и обработки
 * данных. В отличии от структур данных потоки данных могут обладать неограниченным
 * размером.
 * Потоки данных реализуют функциональный подход. Поэтому они не изменяют
 * источники данных.
 * Потоки данных реализуют «отложенные вычисления». Это означает, что
 * промежуточные методы начнут выполняться только тогда, когда будет вызван
 * терминальный метод цепочки.
 * Как и итераторы, так и потоки данных предполагают только разовое выполнение. Для
 * повторного выполнения поток данных нужно будет создать повторно.
 *
 *                           Как создать Stream
 *    Источник                   Методы
 * Collection             stream(), parallelStream()
 *
 * Array                  Arrays.stream(Object[])
 *
 * Статические методы     IntStream.range(int, int), Stream.iterate(Object, UnaryOperator), Stream.of(Object[])
 * для работы с файлами   FIle Files.lines()
 *
 * И еще очень много способов. Так, что способ породить поток данных на основе
 * интересующего вас источника данных возможно придется поискать в документации.
 *
 * *********************************************************************************************************************
 *
 *                       Промежуточные методы
 * Промежуточные методы возвращают потоки данных. Промежуточные методы
 * образуют последовательности операций по обработке данных. Промежуточных методов
 * может быть применено произвольное количество.
 * Промежуточные методы можно разделить на следующие категории (это разбиение
 * условно) по их функционалу:
 * 1) Фильтрация данных
 * 2) Изменение данных
 * 3) Упорядочивание данных
 *
 *                         Список абстрактных промежуточных методов (реализуем с пом лямбды, например,
 *                         компилятор поймет-какой именно метод реализуем по входящим и выходящим параметрам)
 *                          Метод                                           Описание
 * Stream<T> filter (Predicate<? super T> javaCore34.predicate)             Фильтрация данных на основе Predicate
 * Stream<T> sorted (Comparator<? super T> javaCore34.comparator)           Сортировка данных на основе Comparator
 * Stream<T> sorted()                                            Сортировка данных на основе Comparable
 * <R> Stream<R> map (Function<? super T, ? extends R> mapper)   Изменение типа данных потока на основе Function
 * Stream<T> peek (Consumer<? super T> action)                   Выполняет действие над элементов потока
 * Stream<T> distinct()                                          Возвращает поток без дубликатов. Использует equals
 * <R> Stream<R> flatMap (Function<? super T, ? extends Stream<? extends R>> mapper)
 *                                                               Создает поток на основе одного элемента текущего потока
 * DoubleStream flatMapToDouble (Function<? super T, ? extends DoubleStream> mapper)
 *                                                               Создание примитивной специализации
 * IntStream flatMapToInt (Function<? super T, ? extends IntStream> mapper) Создание примитивной специализации
 * LongStream flatMapToLong (Function<? super T, ? extends LongStream> mapper)
 *                                                               Создание примитивной специализации
 * Stream<T> limit (long maxSize)                                Возвращает первые maxSize элементов
 * Stream<T> skip (long n)                                       Пропуск первых n элементов потока
 *
 *
 *                                  Список промежуточных методов по умолчанию
 *                            Метод                                              Описание
 * default Stream<T> dropWhile (Predicate<? super T> javaCore34.predicate) Для упорядоченных потоков, возвращает поток в котором останутся
 *                                                              только элементы после последнего срабатывания Predicate
 * default Stream<T> takeWhile (Predicate<? super T> javaCore34.predicate) Возвращает поток, в котором останется первый элементы для
 *                                                              которых Predicate возвращал true
 *
 *
 *                              Список статических промежуточных методов (вызываем чере имя интерфейса)
 * Метод Описание
 * static <T> Stream<T> concat (Stream<? extends T> a, Stream<? extends T> b) Конкатенация потоков данных
 * static <T> Stream<T> empty() Возвращает пустой поток
 * static <T> Stream<T> generate (Supplier<? extends T> s) Создает поток где элементы создаются Supplier
 * static <T> Stream<T> iterate (T seed, Predicate<? super T> hasNext,
 * UnaryOperator<T> next)
 * Создает поток путем применения UnaryOperator к seed,
 * при условии что Predicate вернет true
 * static <T> Stream<T> iterate (T seed, UnaryOperator<T> f) Создает поток путем применения UnaryOperator к seed
 * static <T> Stream<T> of (T t) Поток их одного элемента
 * static <T> Stream<T> of (T... values) Поток из нескольких элементов
 * static <T> Stream<T> ofNullable (T t) Возвращает последовательный Stream, содержащий
 * единственный элемент, если не равен null, в противном
 * случае возвращает пустой Stream.
 *
 *
 * *********************************************************************************************************************
 *
 *                                   Терминальные методы
 * Терминальные методы заканчивают цепочку обработки элементов потока данных.
 * Т.е. если промежуточные методы можно описать как способ фильтрации,
 * упорядочивания, или даже изменения данных, то терминальные методы это
 * использование результата обработки. Терминальные методы используются для
 * сохранения результата (одно значение, структура данных), выполнение действий над
 * ними и т. д.
 * Вызов терминального метода запускает цепь вычислений, созданную на основе
 * промежуточных методов.
 * Терминальные методы можно разделить по функциональности на:
 * 1) Аккумулирующие данные
 * 2) Выполняющие действие с данными
 * 3) Сохраняющие данные
 * 4) Генерирующие результат на основе данных
 *
 *                            Список абстрактных терминальных методов
 *                          Метод                                          Описание
 * boolean allMatch (Predicate<? super T> javaCore34.predicate) Вернет true если все элементы потока удовлетворяют Prtedicate
 * boolean anyMatch (Predicate<? super T> javaCore34.predicate) Вернет true если хотя бы один элемент потока удовлетворяет Prtedicate
 * <R> R collect (Supplier<R> javaCore34.supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) Реализует аккумулирующую операцию
 * <R, A> R collect (Collector<? super T, A, R> collector) Реализует аккумулирующую операцию с использованием Collector
 *                                                         long count() Вернет количество элементов в потоке данных
 * Optional<T> findAny() Вернет Optional если элемент в потоке есть, или пустой если нет
 * Optional<T> findFirst() Вернет Optional с первым элементом в потоке есть, или пустой если нет
 * void forEach (Consumer<? super T> action) Выполнит действие над каждым элементом потока
 * void forEachOrdered (Consumer<? super T> action) Выполнит действие над каждым элементом потока в порядке потока
 * boolean noneMatch (Predicate<? super T> javaCore34.predicate) Вернет true если не один элемент не удовлетворяет Predicate
 * Optional<T> reduce (BinaryOperator<T> accumulator) Реализует аккумулирующую операцию
 * T reduce (T identity, BinaryOperator<T> accumulator) Реализует аккумулирующую операцию
 * <U> U reduce (U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) Реализует аккумулирующую операцию
 *                                                                                          Object[] toArray() Вернет данные в виде массива
 * <A> A[] toArray (IntFunction<A[]> generator) Вернет данные в виде массива с возможностью управлять размером массива
 * Optional<T> max (Comparator<? super T> javaCore34.comparator) Вернет максимальный элемент из потока данных
 * Optional<T> min (Comparator<? super T> javaCore34.comparator) Вернет минимальный элемент из потока данных
 *
 *                      Знакомство с использованием Stream API
 * Для знакомства с использованием Stream API выделим из всего многообразия
 * промежуточных и терминальных методов только небольшую их часть. И на этапе
 * знакомства будем использовать только их. Впоследствии мы изучим остальные более
 * подробно.
 *
 * далее в следующем семпле.
 *
 */

package javaCore34.streamAPI_1.sample1;

public class Teoriy {
}

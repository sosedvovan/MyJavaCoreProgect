/**\
 *                             Stream API Часть 4
 *
 *              Промежуточные методы для изменения порядка потока
 *
 *              Сохранение порядка потоком
 * Потоки данных могут как сохранять порядок следования данных, так и не сохранять.
 * В общем случае если поток данных был порожден на основании структуры данных
 * сохраняющих порядок вставки, то поток также сохраняет порядок данных. Например
 * если поток порожден на основании списка или массива, то поток данных будет сохранять
 * порядок следования элементов. Если же поток порожден на основании Set то поток не
 * будет сохранять порядок данных.
 * Ряд промежуточных методов может изменять порядок в потоке. Например sort(). Или
 * указывать на то, что можно не сохранять порядок в потоке. Для последовательных
 * потоков не сохранение порядка не дает никаких преимуществ. Однако для параллельных
 * потоков это может дать прирост производительности. Также можно увеличить прирост
 * производительности некоторых терминальных методов.
 * ***************************************************************************************
 * О порядке выполнения операций в потоке
 * Промежуточные методы которые не изменяют порядок потока выполняются один за
 * одним для каждого элемента данных. Т.е. сначала берется один элемент и для него
 * выполняется вся последовательность промежуточных методов и терминальный.
 *
 * List<String> list1 = List.of("A1", "A2", "A3");          //имеется массив
 * Stream<String> stream = list1.stream()                   //порождаем поток на этом массиве
 * .filter(n -> {                                           //в фильтр добавим sout log
 * System.out.println("Filter " + n);
 * return n.length() <= 2;
 * })
 * .map(n -> {                                              //в метод изменения данных добавим sout log
 * System.out.println("Map " + n);
 * return "_" + n;
 * });
 * //увидим,что сначала берется один элемент и для него выполняется вся последовательность промежуточных методов и терминальный:
 * stream.forEach(n -> System.out.println("forEach " + n));
 *
 * //По этой причине стоит уделять много внимания оптимальности описания порядка
 * терминальных методов. Это может уменьшить количество операций. ТЕ СНАЧАЛА ФИЛЬТР, ПОТОМ ИЗМЕНЯЕМ ОСТАВШИЕСЯ
 *
 * //если В примере поменяем местами метод filter и map. Результат будет одинаков, но в
 * первом случае будет выполнено 5 операций, а во втором 7.
 ******************************************************************************************************
 *                     Методы с запоминанием состояния (stateful)
 * Некоторые промежуточные методы для изменения порядка в потоке являются
 * методами с запоминанием состояния. В частности таким является метод sorted. Они
 * используют «горизонтальную» обработку элементов данных. Т.е. сначала накапливают
 * все элементы потока, выполняют операцию и порождают поток на основании результата.
 * List<String> list1 = List.of("A1", "C1", "B1");
 * Stream<String> stream = list1.stream()
 * .sorted((a,b)->{                                 //сортируем- состояние запоминается -накопление
 * System.out.println("Sorted "+a+" "+b);           //СОРТИРОВКУ НАДО СТАВИТЬ ПЕРЕД ТЕРМИНАЛЬНЫМ МЕТОДОМ
 * return a.compareTo(b);                           //ЧТОБЫ МЕНЬШЕ ЭЛЕМЕНТОВ СОРТИРОВАТЬ И СОРТИРОВАТЬ С УЧЕТОМ ИЗМЕНЕНИЙ В МЕТОДЕ map
 * })
 * .filter(n -> {                                   //потом фильтруем - отсеиваем НО ФИЛЬТР НАДО БЫЛО ПРИМЕНИТЬ ПЕРВЫМ!!!!
 * System.out.println("Filter " + n);
 * return n.startsWith("B");
 * }).map(n -> {                                   //изменяем-- ИЗМЕНЯТЬ НАДО ПОСЛЕ ФИЛЬТРА
 * System.out.println("Map " + n);
 * return "_" + n;
 * });
 * stream.forEach(n -> System.out.println("forEach " + n));
 *
 * Вывод в терминале:
 * Sorted C1 A1   накопление
 * Sorted B1 C1   накопление
 * Sorted B1 C1   накопление
 * Sorted B1 A1   накопление
 * Filter A1
 * Filter B1
 * Map B1
 * forEach _B1
 * Filter C1
 ***********************************************
 * Рекомендации по работе с методами с запоминанием состояния
 *
 * Если есть возможность старайтесь использовать методы с запоминанием состояния с
 * минимальным количеством элементов в потоке, так как именно эти методы наиболее
 * ресурсоемкие. Т.е. старайтесь сортировать данные потока (или изменять порядок данных
 * в потоке) как можно ближе к терминальным методам.
 * ******************************************************
 *           Список абстрактных промежуточных методов  для изменения порядка в потоке
 *
 * S unordered()
 * Возвращает эквивалентный поток данных в котором не
 * сохраняется порядок следования элементов который был
 * использован в источнике данных
 *
 * Stream<T> sorted (Comparator<? super T> javaCore34.comparator)
 * Сортировка данных на основе Comparator
 *
 * Stream<T> sorted()
 * Сортировка данных на основе Comparable
 * *****************************************************************************
 *
 */

package javaCore34.streamAPI_4ПромежуточныеМетодыДляИзмененияПорядкаПотока.sample1;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main1 {

    public static void main(String[] args) {

    //                              Метод unordered()

        //unordered() метод который создает поток без сохранения порядка данных. Имеет смысл
        //применять для оптимизации со стороны компилятора (если порядок в потоке не важен).
        //Применение не имеет смысла если последующие методы используют порядок в потоке
        //(limit(), skip() и т.д.)

        List<String> list1 = List.of("A1", "B1", "C1");

        Stream<String> stream = list1.stream()
                .unordered();

        stream.forEach(n -> System.out.println(n));

        //В данном примере изменение порядка потока не приносит никакой выгоды со стороны
        //компилятора, поэтому порядок следования сохраняется.

        //------------------------------------------------------------------------------------------

        //             Метод sorted (Comparator<? super T> javaCore34.comparator)
        //sorted (Comparator<? super T> javaCore34.comparator) упорядочивает элемента потока, что бы они
        //следовали в возрастающем порядке. Отношение порядка устанавливается реализацией
        //Comparator. Метод с запоминанием состояния.

        List<Integer> list = List.of(-2, 4, 0, -5, 3, 2, 5, 1);
        List<Integer> result = list.stream()//порождаем стрим на коллекции
                .sorted((a,b)-> Math.abs(a)-Math.abs(b))//sorted с реаллизацией корпораторы
                .collect(Collectors.toList());//аккумулируем поток в лист
        System.out.println(result);

        //В данном примере происходит упорядочивание данных потока путем сортировки
        //потока целых чисел в порядке возрастания их модуля.

        //--------------------------------------------------------------------------------------------

        //                        Метод sorted ()
        //sorted () упорядочивает элемента потока, что бы они следовали в возрастающем
        //порядке. Отношение порядка устанавливается реализацией Comparable (отношение
        //естественного порядка). Метод с запоминанием состояния.

        List<Integer> list2 = List.of(-2, 4, 0, -5, 3, 2, 5, 1);
        List<Integer> result2 = list2.stream()//порождаем стрим на коллекции
                .sorted()//sorted с компорабле от класса Интеджер
                .collect(Collectors.toList());//аккумулируем поток в лист
        System.out.println(result2);

        //В данном примере происходит упорядочивание элементов потока в естественном порядке.

    }
}

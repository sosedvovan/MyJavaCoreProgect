package javaCore34.predicate.sample2;

import java.util.Arrays;
import java.util.function.BiPredicate;
import java.util.function.IntPredicate;

public class Main {
    public static void main(String[] args) {

        //Пример реализации и использования BiPredicate:
        //принимает (a, b)  и возвращает true или false
        //здесь ссылке на реализацию абстракта интерфейса biPred присвоили реализацию с пом. лямбды
        BiPredicate<String, Integer> biPred = (a, b) -> a.length() > b;

        System.out.println(biPred.test("Hello", 3));

        //В примере показана реализация BiPredicate с помощью лямбда функции. В качестве
        //параметром используются строка и целое число. Логика реализации такова: вернуть
        //результат сравнения длинны строки со значением этого числа. Ниже в примере вызывает
        //метод test этой реализации для строки «Hello» и числа 3. Так, как длинна строки больше
        //значения числа то метод возвращает true.
        //-----------------------------------------------------------------------------------------
                        //Пример использования метода and для BiPredicate:
        BiPredicate<String, Integer> biPred1 = (a, b) -> a.length() < b + 3;
        BiPredicate<String, Integer> biPred2 = (a, b) -> a.length() > b - 3;
        String text = "Hello";
        System.out.println(biPred1.and(biPred2).test(text, 3));

        //В примере продемонстрирована работа метода and. В этом примере две реализации
        //Predicate используются для объединения как логический AND. Функционал подобного
        //объединения заключается в том что строка которая является параметром должна
        //отличаться по длине от заданного числа максимум на 3 единицы как в сторону
        //возрастания, так и в сторону убывания.
        //------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------
        //                 Примитивные специализации функциональных интерфейсов:
        //Существуют специализации интерфейса Predicate для работы с примитивными
        //типами. Т.е. в методе test в качестве параметра использует значение примитивных типов.
        //Эти специализации используются для работы с массивами примитивных типов и для
        //потоков примитивных типов.
        //              Тип                        С каким типом данных работает
        //          IntPredicate                            int
        //          LongPredicate                           long
        //          DoublePredicate                         double
        //Как и у бинарных специализаций у данных специализаций есть методы по умолчанию and, or, negate.

        //         Пример использования примитивной специализации:
        IntPredicate pr = a -> a % 2 == 0;
        System.out.println(pr.test(100));
        //В примере продемонстрирована работа такой примитивной специализации Predicate
        //как IntPredicate. Этот интерфейс предназначен для работы с значением типа int на основе
        //которого генерируется значение типа boolean. Реализация в примере вернет true для
        //четных чисел

        //               Использование IntPredicate в качестве параметра метода:
        int[] array = new int[] { -4, 1, 6, -3, 0, 1, 7 };//имеется такой массив
        int even = countElement(array, a -> a % 2 == 0);//Передаем в качестве параметра static метода массив array и лямбда функцию
        int odd = countElement(array, a -> a % 2 != 0);//передаем другую реализацию
        System.out.println(Arrays.toString(array));
        System.out.println("Even = " + even);//покажит сколько четных чисел в массиве
        System.out.println("Odd = " + odd);//покажет сколько не четных чисел в массиве

    }

    //этот метод принимает реализацию предиката IntPredicate pr как параметр метода
    public static int countElement(int[] array, IntPredicate pr) {
        int count = 0;//переменная счетчик
        for (int i = 0; i < array.length; i++) {//итерируемся по всему массиву
            if (pr.test(array[i])) {//через ссылку на реализацию в параметр абстракта передаем очередной эллемент массива
                count += 1;         // и если возвращается true, увеличиваем счетчик
            }
        } return count;
    }
}

/**
 * Бинарная специализация Predicate в виде BiPredicate:
 *
 * Predicate имеет бинарную специализацию (binary specializations) в виде
 * функционального интерфейса BiPredicate<T, U>. Бинарная специализация это вариация
 * интерфейса описывающая методы принимающие два параметра. Т.е. теперь результат
 * который вернет реализация BiPredicate зависит от двух объектов.
 *
 * Список методов интерфейса BiPredicate<T, U>:
 *
 *                 Метод                                       Описание
 * boolean test (T t, U u)                               Проверяет удовлетворяет ли объект по ссылке t и
 *                                                       объект по ссылке u заданному условию. Если да то
 *                                                       метод должен вернуть true, в противном случае false.
 *
 * default Predicate<T,U> and (Predicate<? super T, ? super U> other)
 *                                                       Возвращает составной предикат (в виде краткого
 *                                                       логического И) на основе текущего и того что
 *                                                       выступает параметром other.
 *
 * default Predicate<T,U> or (Predicate<? super T, ? super U> other)
 *                                                       Возвращает составной предикат (в виде краткого
 *                                                       логического ИЛИ) на основе текущего и того что
 *                                                       выступает параметром other.
 *
 * default Predicate<T,U> negate()                       Возвращает предикат в виде логического НЕ на
 *                                                       основании текущего предиката
 *************************************************************************************************
 *
 *
 *
 */

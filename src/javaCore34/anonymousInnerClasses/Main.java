package javaCore34.anonymousInnerClasses;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.Comparator;

//Пример объявления и использования анонимного класса в методе
public class Main {

    public static void main(String[] args) {

        String[] words = new String[]{"Hello", "Cat", "Home", "Student"};

        //-----------------------------------------------------------------------------------------------------
        //Реализация интерфейса Comparator с помощью анонимного класса объявленного в методе main.
        //получили ссылку cmpMain - это ссылка на объект класса без имени, кот implements Comparable<String>
        //и кот реализует анонимный метод этого интерфейса нужным нам образом
        //а изготовили мы эту ссылку, потому что она нужна методу Arrays.sort()
        Comparator<String> cmpMain = new /*далее указываем интерфейс*/ Comparator<String>() {//Объявление анонимного класса

            //Объявление дополнительного поля внутри анонимного класса
            public int direction;
            //Решение проблемы отсутствия явного конструктора в
            //анонимных классах- нестатический блок:
            {
                direction = 1; //Блок инициализации создаваемого объекта
            }

            @Override
            public int compare(String o1, String o2) {
                //Использование дополнительного поля direction внутри анонимного класса
                return o1.length() - o2.length() * direction;
            }
        };//закрыли анонимный класс
        //--------------------------------------------------------------------------------------------------------

        Arrays.sort(words, cmpMain);//Использование объекта анонимного класса
        //toString(words)- один из перегруженных методов класса Arrays(сборник методов для работы с обычными массивами)
        System.out.println(Arrays.toString(words));

      // int temp = cmp.direction; //Ошибка компиляции. Извне анонимного класса поле недоступно.

        //---------------------------------------------------------------------------------------------------------

        //Получение и вывод на экран имени анонимного класса - поля cmp класса OuterClass:
        //к объекту анонимного класса(как и к объекту внутреннего класса) обращаемся через объект внешнего: oc.cmp....
        OuterClass oc = new OuterClass("Hello");
        System.out.println(oc.cmp.getClass().getName()); //javaCore34.anonymousInnerClasses.OuterClass$1

        //Получение и вывод на экран имени анонимного класса - объявленного в этом же методе:
        System.out.println(cmpMain.getClass().getName()); //javaCore34.anonymousInnerClasses.Main$1

        //---------------------------------------------------------------------------------------------------------


        //Пример создания объекта анонимного класса в статическом контексте ,
        //в случае, если Анонимный класс используется для создания статического поля или в статическом
        // методе (здесь Анонимный класс в static void main объявлен). В таком случае нужно получить ссылку на его класс и,
        // используя метод newInstance() (при этом используя правильный конструктор), создать объект.
        Comparator<String> cmp2 = null;//создали новую ссылку
        try {
            cmp2 = cmpMain.getClass().newInstance();//новой ссылки присвоили новый объект созданный newInstance()
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        System.out.println(cmp2 == cmpMain);//false


        //Пример создания объекта анонимного класса в не статическом контексте
        //(будем работать с анонимным классом, объявленном в классе OuterClass)
        //Если Анонимный класс используется при создании не статического поля или в не
        //статическом методе - нужно создать объект внешнего класса. Получить
        //ссылку на класс анонимного и, используя метод newInstance() (при этом используя
        // правильный конструктор и явно передав в него ссылку на объект внешнего класса),
        // создать объект:
        OuterClass ocClass = new OuterClass("Cat");//Создание объекта внешнего класса
        Comparable<String> cmp3 = null;//создали новую ссылку
        try {
            //Получение нужного конструктора и передача в него ссылки на объект внешнего класса:
            cmp3 = oc.cmp.getClass().getDeclaredConstructor(OuterClass.class).newInstance(oc);
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException |
                InvocationTargetException | NoSuchMethodException | SecurityException e) {
            e.printStackTrace();
        } System.out.println(oc.cmp);//javaCore34.anonymousInnerClasses.OuterClass$1@27d6c5e0
        System.out.println(cmp2 == oc.cmp);//false
    }
    }


/**
 * Анонимные вложенные классы — разновидность внутренних классов. При создании
 * класса его имя явно не указывается (поэтому они и называются анонимными).
 * Использование таких классов обычно обусловлено необходимостью однократного
 * создания объекта класса, реализующего тот или иной абстрактный класс или интерфейс.
 * Объявление такого класса выполняется одновременно с созданием его объекта
 * посредством использования оператора new.
 *
 * Анонимные классы - удобный инструмент разработки, применяемый в случае:
 * ● Необходимости создания единственного экземпляра класса с переопределенными
 * методами
 * ● Необходимости однократной реализации интерфейса
 *
 * Анонимные классы всегда выступают в роли подкласса обычного класса или как
 * реализация абстрактного класса или интерфейса. Синтаксис объявления анонимного
 * класса таков: после оператора new вы вызываете конструктор класса (в случае обычного
 * наследования) или указываем абстрактный класс или интерфейс, после которого
 * следуют пустые круглые скобки (в случае реализации), затем в фигурных скобках
 * описывается тело класса.
 * Важно! После фигурных скобок тела анонимного класса обязательно ставить точку с
 * запятой.
 *
 * Анонимные классы могут быть использованы как внутренние и как локальные
 * внутренние. В зависимости от того, как они применяются, они обладают такими
 * особенностями:
 *
 * Использование в качестве внутренних классов:
 * ● Объект анонимного класса используется в качестве обычного поля: как и в случае
 * внутреннего класса, имеется доступ ко всем членам внешнего класса.
 * ● Объект анонимного класса используется в качестве статического поля: доступ
 * имеется только к статическим полям внешнего класса.
 *
 * Использование в качестве локальных внутренних классов:
 * ● Используется в статическом методе. Имеется доступ к статическим членам
 * внешнего класса, и final и effective-final переменным метода.
 * ● Используется в не статическом методе. Доступ ко всем полям внешнего класса, и
 * final и effective-final переменным метода.
 *
 * Анонимные классы в Java обладают рядом ограничений:
 * ● Конструкторы в анонимных классах ни определять, ни переопределять нельзя.
 * Анонимный класс не может иметь конструкторов, поскольку имя конструктора должно
 * совпадать с именем класса, а в данном случае класс не имеет явно заданного имени
 * ● Анонимный класс может реализовать только один интерфейс
 * ● Анонимный класс не может ничего наследовать - (он неявный наследник базового)
 * ● От анонимного класса нельзя наследоваться (нет явно заданного имени класса)
 * ● Анонимный класс не может определять статические поля, методы или классы, кроме
 * констант static final
 * ● В анонимном классе вы не можете объявить статические блоки инициализации
 * ● В анонимном классе вы не можете объявить интерфейс
 * ● Вы можете объявить и использовать в анонимном классе члены, которых нет в
 * суперклассе. Но ссылка на объект анонимного класса всегда имеет тип суперкласса,
 * поэтому извне анонимного класса использование их таких полей невозможно
 *
 * И хотя в анонимных классах нельзя определять конструкторы, можно частично
 * решить эту проблему, используя не статический (статические запрещены) блок
 * инициализации. К недостаткам такого решения стоит отнести факт, что блок
 * инициализации может быть только один, и, как следствие, реализовать перегруженные
 * конструкторы уже не получится.
 *
 * Может показаться, что у анонимных классов нет имени. Но это не так. У анонимных
 * классов нет имени, задаваемого в явном виде. Они просто получают свое имя неявно. Это
 * легко проверить, вызвав для объекта анонимного класса метод getClass().
 *
 * Обычно анонимные классы используются для создания одного объекта. Однако при
 * необходимости вы можете создать произвольное количество объектов анонимного класса.
 * Для этого нужна ссылка на уже существующий объект анонимного класса.
 * Дальнейшее поведение различают для двух случаев:
 * ● Анонимный класс используется для создания статического поля или в статическом
 * методе. В таком случае нужно получить ссылку на его класс и, используя метод
 * newInstance() (при этом используя правильный конструктор), создать объект
 * ● Анонимный класс используется при создании не статического поля или в не
 * статическом методе. В таком случае нужно создать объект внешнего класса. Получить
 * ссылку на класс анонимного и, используя метод newInstance() (при этом используя
 * правильный конструктор и явно передав в него ссылку на объект внешнего класса),
 * создать объект
 */

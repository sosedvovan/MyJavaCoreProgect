package javaCore34.consumer.sample1;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.IntConsumer;

//Пример реализации Consumer
public class Main {

    public static void main(String[] args) {

        //       Пример реализации Consumer с помощью класса:
        Consumer<String> cons1 = new HashCodePrinter<>();
        cons1.accept("Hello");//Использование метода этого интерфейса


        //      Пример реализации Consumer с помощью лямбда функции и ссылки на метод:
        Consumer<String> cons11 = (a) -> System.out.println("{" + a + "}");
        Consumer<String> cons2 = Main::simpePrinter;
        cons11.accept("Hello world");
        cons2.accept("Hello world");


        //                  Побочный эффект метода:
        //Побочный эффект функции (метода) - возможность функции в процессе
        //выполнения:
        //● читать и модифицировать значения глобальных переменных или полей класса;
        //● осуществлять операции ввода-вывода;
        //● реагировать на исключительные ситуации, вызывать их обработчики.
        //Если вызвать функцию с побочным эффектом дважды с одним и тем же набором
        //значений входных аргументов, может случиться так, что в качестве результата будут
        //возвращены разные значения.
        //Очень часто реализация этого интерфейса опирается именно на побочные эффекты.



        //        Пример использования побочного эффекта реализацией Consumer:
        //имеем лист:
        List<String> result = new ArrayList<>();
        //имеем стрингу:
        String s = "J";
        //создаем Consumer<String>, в реализации- на входе строка, на выходе- ничего
        //проверка, с какой буквы начинается поданная в аргументы абстракта строка:
        Consumer<String> cons3 = a -> {
            if (a.startsWith(s))//если первая буква "J", тогда добавляем элемент в массив
                result.add(a);//Доступ к внешним данным
        };
        cons3.accept("Java");//будет добавлен в массив
        cons3.accept("Julia");//будет добавлен в массив
        cons3.accept("Python");//не будет добавлен в массив  - похоже на предикат
        System.out.println(result);

        //И хотя сама реализация Consumer не возвращает значения, за счет использования
        //побочного эффекта (доступ и заполнение списка) был заполнен внешний список.


        //              Consumer в стандартной библиотеке:
        //В интерфейсе Iterable<T> объявлен метод по умолчанию:
        //default void forEach (Consumer<? super T> action)
        //Этот метод выполняет действие заданное с помощью реализации Consumer для
        //каждого элемента участвующего в итерации. Стоит обратить внимание на ситуацию
        //изменения с помощью Consumer или элементов участвующих в итерации или структуры
        //данных по которой производится итерации.

        //         Пример использования метода forEach:
        //МОЖНО ВЫВЕСТИ КОЛЛЕКЦИЮ БЕЗ ЦИКЛА!!!

        List<String> list = new ArrayList<>(List.of("Java", "Fortran", "Python"));
        Consumer<String> cons4 = a -> System.out.println(a);
        list.forEach(cons4);

        //В примере показано применение метода forEach. Действие заданное с помощью
        //Consumer сводится просто к выводу элемента на экран с новой строки. В итоге все
        //содержимое списка выводится на экран.


        //                   Метод andThen:
        //В Consumer объявлен метод по умолчанию:
        //default Consumer<T> andThen (Consumer<? super T> after)
        //Этот метод принимает в качестве параметра реализацию Consumer тип входного
        //параметра которого совместим с типом текущей реализации. В итоге мы получим новую
        //реализацию Consumer которая будет композицией текущей и той что используется в
        //качестве параметра. Первой будет выполнена текущая реализация, после чего
        //используемая в качестве параметра.

        //             Пример использования метода andThen:

        Consumer<String> cons5 = a -> System.out.print("*" + a );//Первая реализация
        Consumer<String> cons6 = a -> System.out.println("*");//Вторая реализация
        Consumer<String> result2 = cons5.andThen(cons6);//Их композиция
        result2.accept("Hello");

        //В пример показана композиция реализаций Consumer. Первая реализация выводит *
        //и строку переданную в качестве параметра, второй просто выводит * переводит строку.
        //Их комбинация выводит * строку *.


        //               Бинарная специализация Consumer в виде BiConsumer:
        //Consumer<T> имеет бинарную специализацию (binary specializations) в виде
        //функционального интерфейса BiConsumer<T, U>. Бинарная специализация это вариация
        //интерфейса описывающая методы принимающие два параметра и не возвращающая
        //результата.

        //Список методов интерфейса BiConsumer<T, U>:
        //
        //void accept (T t, U u)
        //Операция над объектами ссылки на которые
        //используются в качестве параметров. Не возвращает
        //результат.
        //
        //default BiConsumer<T, U> andThen (BiConsumer<? super T, ? super U> after)
        //Создание композиции из реализаций BiConsumer.
        //Первой вызывается текущая реализация после того
        //вызывается переданная в качестве параметра.

        //          Абстрактный метод интерфейса BiConsumer<T,U>:

        //В качестве абстрактного метода интерфейса BiConsumer<T,U> выступает метод void
        //accept (T t, U u). Его реализация выполняет операцию над объектами ссылки на которые
        //используются в качестве параметров. Не возвращает результат.

        //                  Пример реализации BiConsumer:

        BiConsumer<String, Integer> biCons = (a, b) -> System.out.println(a.repeat(b));
        biCons.accept("Hello ", 3);

        //В примере показана реализация BiConsumer. Суть его реализации сводится к выводу
        //на экран строки повторенной определенное количество раз.


        //           BiConsumer в стандартной библиотеке:
        //В интерфейсе Map<K,V> объявлен метод по умолчанию:
        //default void forEach (BiConsumer<? super K, ? super V> action)
        //Этот метод выполняет действие заданное с помощью реализации BiConsumer для
        //каждой пары ключ — значение хранимой в реализации Map.

        //          Пример применения forEach:

        //имеется мапа
        Map<Integer, String> map1 = Map.of(1, "one", 2, "two", 5, "five");
        //сделаем контсуммер (нет возвращ. результата) печатает значение энтри мапы, повторяя его столько раз, как значения ключа в этом энтри
        BiConsumer<Integer, String> biConsp = (a, b) -> System.out.println((b + " ").repeat(a));
        map1.forEach(biConsp);

        //В примере реализация BiConsumer используется для того что бы вывести на экран
        //все пары ключ-значение. Причем значение выводится на экран столько раз, чему равно
        //значение ключа.


        //              Примитивные специализации Consumer:
        //Примитивные специализации Consumer используются в случае использования
        //примитивных типов в качестве параметра
        //   Название            Описание
        //IntConsumer          Использует в качестве параметра тип int
        //LongConsumer         Использует в качестве параметра тип long
        //DoubleConsumer       Использует в качестве параметра тип double
        //Каждая примитивная специализация содержит метод по умолчанию andThen для
        //создания композиции.

        //                Пример применения IntConsumer:
        //В примере показано использование IntConsumer. Используя параметр типа int
        //выводится на экран четное или не четное это значение:

        IntConsumer cons = a -> {
            if (a % 2 == 0) {
                System.out.println(a + " even number");
            } else {
                System.out.println(a + " odd number");
            }
        };
        cons.accept(5);


    }//закрыли главный метод

    public static <T> void simpePrinter(T operand) {
        System.out.println("{" + operand + "}");
    }

}//закрыли класс Main

//Реализация с помощью класса/ реализованный абстракт ничего не возвращает (как это и требуется),
// а только выводит в консоль
class HashCodePrinter<T> implements Consumer<T> {
    @Override
    public void accept(T t) {
        System.out.println(t.hashCode());
    }
}

/**
 *                Функциональный интерфейс Consumer:
 *
 *   Consumer<T> - функциональный интерфейс появившийся в Java 8. Используется для
 * описания операции над объектом без возврата результата. Реализация этого интерфейса
 * опирается на побочные эффекты при выполнении операции. Для работы необходимо
 * импортировать пакет java.util.javaCore34.function.Consumer
 *
 * Список методов интерфейса Consumer<T>:
 *
 * void accept(T t)
 * Выполняет операцию над объектом, ссылка на который,
 * передается в качестве параметра.
 *
 * default Consumer<T> andThen (Consumer<? super T> after)
 * Возвращает композицию Consumer. Первым выполнится
 * текущий Consumer, после чего будет выполнен Consumer
 * который передается в качестве параметра.
 *
 *
 *            Абстрактный метод интерфейса Consumer<T>:
 *
 * В качестве абстрактного метода интерфейса Consumer<T> выступает метод:    void accept(T t).
 *  Этот метод описывает операцию над объектом которая не возвращает результат.
 *
 *
 *
 */

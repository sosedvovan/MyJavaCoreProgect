package javaCore34.function.sample3;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

public class Main {

    public static void main(String[] args) {

        //              Function в стандартной библиотеке:
        //В интерфейсе Map объявлен метод по умолчанию:
        //default V computeIfAbsent (K key, Function<? super K, ? extends V> mappingFunction)
        //Этот метод пытается получить значение по указанному ключу (key). Если такой ключ
        //есть то метод вернет его значение. Если же такого ключа нет (или с ним связанно
        //значение null) то будет получено значение на основе ключа с использованием
        //mappingFunction. Эта пара будет добавлена в карту, вычисленное значение будет
        //возвращено в результате работы метода.

        Map<Integer, String> numbers = new HashMap<>(Map.of(1, "one", 5, "five"));
        Integer num = 2;
        //Function в качестве параметра метода computeIfAbsent из интерфейса Map
        String result = numbers.computeIfAbsent(num, n -> "number_" + n);
        System.out.println(numbers);
        System.out.println(result);

        //В этом примере выполняется получение значения связанного с ключом 2. Такого
        //ключа в карте нет. В таком случае будет вычислено значение на основании ключа (для
        //реализации Function) использовалась лямбда функция. Полученное значение и ключ
        //добавляются в карту. Сам же метод вернет вычисленное значение
        //------------------------------------------------------------------------------------------
        //                                 Метод andThen:
        //В Function объявлен метод по умолчанию:
        //default <V> Function<T, V> andThen (Function<? super R, ? extends V> after)
        //Этот метод принимает в качестве параметра реализацию Function тип входного
        //параметра которого совместим с типом результата текущей реализации. В итоге мы
        //получим новую реализацию Function которая будет композицией двух функций. Первой
        //будет вычисляться текущая функция, после чего вторая функция использует результат
        //первой как входной параметр и на ее основе вернет новое значение.

        //!!!!!!-----!!!!!второй параметр fun1 - String[] должен быть подан в первый параметр fun2, чтобы andThen() работал.

        //здесь строка(на входе в функцию) превращается в массив строк с разделением по пробелам:
        Function<String, String[]> fun1 = a -> a.split(" ");//Первая реализация

        //здесь массив строк (на входе в функцию) превращается в интовый массив(число по длине элемента строкового массива):
        Function<String[], int[]> fun2 = Main::getLength;//Вторая реализация

        Function<String, int[]> fun3 = fun1.andThen(fun2);//Их композиция- считай сделали третью функцию

        int[] result2 = fun3.apply("Java the best");//композиция обращается к абстракту передавая в него строку

        System.out.println(Arrays.toString(result2));//покажем обычный интовый массив с пом. Arrays.toString

        //-----------------------------------------------------------------------------------------------
        //             Метод compose: то же, что и предидущий метод andThen, только обратная очередь применения fun2 и fun1

        //В Function объявлен метод по умолчанию:
        //default <V> Function<V, R> compose (Function<? super V, ? extends T> before)
        //Этот метод принимает в качестве параметра реализацию Function тип результата
        //которого совместим с типом входного параметра текущей реализации. В итоге мы получим
        //новую реализацию Function которая будет композицией двух функций. Первой будет
        //вычисляться функция которая использовалась в качестве параметра, после чего текущая
        //функция использует результат первой как входной параметр и на ее основе вернет новое
        //значение.

        Function<String, String> fun11 = a -> a.replaceAll("[^A-Za-z]", "");
        Function<String, Integer> fun22 = a -> a.length();
        Function<String, Integer> fun33 = fun22.compose(fun11);
        String text = "Hello world 1234, 621, a 15";
        System.out.println(fun33.apply(text));

        //В этом примере первая реализация (fun1) используется как подготовительная (она
        //удаляет все что не является буквой английского алфавита из строки), а вторая
        //реализация (fun2) возвращает длину строки. Их композиция позволяет вычислить
        //сколько букв английского алфавита в строке. Обратите внимание что теперь первой
        //сработает fun1 и только потом fun2.

        //В чем разница между andThen и compose
        //На самом деле разница между andThen и compose заключается в том какая функция
        //будет вызвана первой, а какая второй.
        //● andThen — первая текущая, второй параметр.
        //● compose — первой параметр, второй текущая

        //----------------------------------------------------------------------------------------------
        //                             Статический метод identity:

        //В Function объявлен статический метод:
        //static <T> Function<T, T> identity()
        //Этот метод возвращает реализацию Function которая всегда возвращает значение
        //равное значению входного параметра. Т.е. то что подаете на вход, то и получаете на
        //выходе.

        Function<Integer, Integer> fun = Function.identity();//Вызов identity
        System.out.println(fun.apply(100));
    }

    public static int[] getLength(String[] arr) {
        int[] result = new int[arr.length];
        for (int i = 0; i < result.length; i++) {
            result[i] = arr[i].length();
        } return result;
    }
}

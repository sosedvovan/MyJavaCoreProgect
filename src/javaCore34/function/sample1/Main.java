package javaCore34.function.sample1;

import java.util.function.Function;

public class Main {
    public static void main(String[] args) {

        //             Абстрактный метод интерфейса Function<T,R>:
        //В качестве абстрактного метода интерфейса Function<T,R> выступает метод R apply
        //(T t). Его реализация и должна вернуть ссылку на объект (типа R) созданный на основе
        //объекта, ссылка на который выступает параметром метода (ссылка типа T t). Так, как
        //интерфейс функциональный то его можно реализовать всеми средствами для реализации
        //обычных интерфейсов так и с помощью лямбда функций и ссылок на методы.

        //-----------------------------------------------------------------------------------------------
        //Пример реализации Function с помощью класса:
        //ссылке на реализацию присваиваем объект класса, имплементирующий интерфейс:
        // implements Function<String, Integer>   (ищи сам класс внизу)
        Function<String, Integer> fun = new StrToLength();
        System.out.println(fun.apply("Hello"));//Использование метода этого интерфейса чз ссылку на реализацию типа интерфейс
        //-----------------------------------------------------------------------------------------------
        //           Пример реализации Function с помощью лямбда функции и ссылки на метод:
        Function<String, Integer> fun1 = a -> a.length();//Реализация с помощью лямбда функции
        System.out.println(fun1.apply("Hello"));
        Function<String, Integer> fun2 = String::length;//Реализация с помощью ссылки на метод
        System.out.println(fun2.apply("World"));
        //В этих примерах продемонстрирована реализация Function<String, Integer> с
        //помощью лямбда функции и ссылки на метод. Обе реализации на основе строки
        //генерируют целое число равное длине этой строки.
        //------------------------------------------------------------------------------------------------
        //           Подробнее о реализации с помощью лямбда функции:
        //           Function<String, Integer> fun1 = a -> a.length();
        //здесь первая а - это аргумент абстрактного метода интерфейса Integer apply (String t).
        // -> a.length();- это Результат созданный на основе параметра (результат это Integer- как и надо)
        //------------------------------------------------------------------------------------------------
        //          Пример использования Function в качестве параметра метода:

        //у нас есть строка:
        String text = "Java the best!";
        //получаем реализацию абстрактного метода функционального интерфейса:
        //те мы отдаем строку, а должны получить число на основе строки- те подсчитать что-либо в строке.
        Function<String, Integer> fun3 = Main::countWhiteSpace;//Реализация ссылкой на метод
        //вызываем static метод applyToStr, передавая ему в аргументы нашу строку и ссылку на реализацию абстракта:
        //(сам метод ищи внизу)
        System.out.println(applyToStr(text, fun3));
        //-------------------------------------------------------------------------------------------------
            //В СЛЕДУЮЩЕМ СЕМПЛЕ БУДЕТ Пример использования Function в качестве параметра ПАРАМЕТРИЗИРОВАННОГО метода
    }//закрываем метод main

    //метод принимает нашу строку и ссылку Function fun на реализацию абстракта в качестве параметра:
    //если в аргументы придет ссылка на другую реализацию, то наша строка будет обрабатываться по другому.
    //получается, что мы создали универсальный метод для строк
    public static Integer applyToStr(String text, Function<String, Integer> fun) {
        //в теле данного метода по ссылке с реализацией обращаемся к абстракту и передаем ему нашу строку.
        // те применяем Function fun:
        return fun.apply(text);
    }

    //метод- реализующий абстракт:
    public static Integer countWhiteSpace(String text) {
        int n = 0;//создаем счетчик
        char[] s = text.toCharArray();//разбиваем строку(пришедшую в аргументы) на чары и помещаем их в массив чаров
        for (int i = 0; i < s.length; i++) {//в цикле проходим по этому массиву с чарами
            if (s[i] == ' ') {//если попадается элемент- пробел:
                n = n + 1;//увеличиваем счетчик
            }
        }
        return n;//возвращаем счетчик- это кол-во пробелов в строке
    }
}//закрываем класс Main

//Реализация абстрактного метода фуекционального интерфейса с помощью класса:
class StrToLength implements Function<String, Integer> {

    @Override
    public Integer apply(String t) {
        return t.length();
    }
}

/**
 * Функциональный интерфейс Function
 * Function<T,R> - функциональный интерфейс появившийся в Java 8. Используется для
 * описания функции генерирующей на основании объекта одного типа объект другого (или
 * такого же) типа. Используется в методах создания одних объектов на основании других
 * или для преобразования одних значений в другие. Для использования необходимо
 * импортировать пакет java.util.javaCore34.function.
 * <p>
 * Список методов интерфейса Function<T,R>
 * Метод                                         Описание
 * R apply(T t)
 * Создает на основании объекта ссылка на который
 * используется в качестве параметра новый объект и
 * возвращает ссылку на него
 * <p>
 * default <V> Function<T, V> andThen (Function<? super R, ? extends V> after)
 * Возвращает композицию функций. Сначала будет
 * применяться текущая функция и к ее результату будет
 * применена функция выступающая в качестве параметра.
 * <p>
 * default <V> Function<V, R> compose (Function<? super V, ? extends T> before)
 * Возвращает композицию функций. Сначала будет
 * применяться функция выступающая в качестве параметра и
 * к ее результату будет применена текущая функция.
 * <p>
 * static <T> Function<T, T> identity()
 * Возвращает функцию которая возвращает свой входной
 * параметр.
 */

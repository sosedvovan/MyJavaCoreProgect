package javaCore34.privateMethodsInterfase.sample1;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;

//область применения не статических default методов в интерфейсах.
//класс, который имплементит этот интерфейс- сможет логировать в файл ошибки и предупреждения
//общая логика 2-х default методов для избегания дублирования кода, вынесена в private метод,кот не может наследоваться
public interface Logger {

    public default void writeErrorMessage(String message) throws IOException {//передаем в арг метода сообщение
        message += new Date() + message;//собираем строку с датой
        File file = new File("Errors.CSV");//создаем файл
        writeToCSVFile(file, message);//отправляем файл и строку в private метод для записи в файл
    }
    public default void writeWarningMessage(String message) throws IOException {//аналогично первому методу
        message += new Date() + message;
        File file = new File("Warnings.CSV");
        writeToCSVFile(file, message);
    }
    private void writeToCSVFile(File file, String message) throws IOException {//принимаем файл и строку
        try (PrintWriter pw = new PrintWriter(new FileWriter(file, true))) {//включаем дозапись в файл
            pw.print(message + ";");//печатаем в файл сообщение
        } catch (IOException e) {
            throw e;
        }
    }
}

/**
 * Указанный интерфейс является заготовкой для инструмента логирования сообщений
 * о ошибках или предупреждений. Методы по умолчанию сохраняют сообщения о ошибках
 * (добавив время записи сообщения) в scv файл. Метод сохранения вынесен в отдельный
 * private метод, так как используется одновременно в двух default методах. Выгодой от
 * такого решения будет то, что этот метод не будет использован в классах которые
 * реализуют этот интерфейс (под реализацией понимается переопределение default
 * методов). Например возможна система логирования в виде записи в базу данных, и
 * механизм записи в файл в такой реализации явно будет излишним.
 *
 * те в классе наследнике можно переопределить default методы таким образом, чтобы запись шла в ДБ,
 * а к private методу интерфейса можно будет не обращаться
 */


/**
 * private методы в интерфейсах
 *
 * Начиная с Java 1.9 в интерфейсах появляется возможность объявлять в интерфейсах
 * private методы. Это могли быть как статические, так и не статические методы. Однако
 * private методы не могут быть абстрактными, т. е. они обязательно должны содержать
 * реализацию.
 * private методы являются дополнением к default методам. В них описываются блоки
 * кода которые не желательно описывать в default методах, так как они не нужны в
 * подинтерфейсах и в классах, которые будут реализовывать интерфейс. private методы
 * не наследуются.
 *
 * У private методов в интерфейсах есть ряд особенностей:
 * ● у private методов есть тело, они не абстрактные
 * ● они могут быть как статическими, так и не статическими
 * ● они не наследуются
 * ● они могут вызывать другие методы интерфейса
 * ● private не статические методы могут вызывать другие private, абстрактные,
 * статические методы или методы по умолчанию
 * ● private статические методы могут вызывать только другие статические и
 * приватные статические методы
 *
 * private методы используются для скрытия общей логики используемой в default
 * методах интерфейсов. При таком подходе default методы наследуются классами, а private
 * соответственно нет.
 */

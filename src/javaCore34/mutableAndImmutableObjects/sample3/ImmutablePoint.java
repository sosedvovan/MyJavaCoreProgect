package javaCore34.mutableAndImmutableObjects.sample3;

import java.util.Arrays;

//Описание класса для создания неизменяемых объектов в
//случае, когда одно поле ссылка на другой объект(коллекцию)
public class ImmutablePoint {

    private final int[] coord;//Ссылка на изменяемый объект- несмотря на то, что final-содержимое массива можно менять-
    //исправим это:

    //конструктор создающий неизменяемый объект(нельзя будет изменить содержимое  массива поля)
    // а, надо будет создавать новый объект с новым содержимым массива:
    public ImmutablePoint(int[] coord) {//Создание копии объекта, и присвоение полю ссылки на эту копию
        //(int[] coord) - это новый массив со своей ссылкой  придет из другого класса,
        // и по правилам неизменяемых объектов надо создать копию пришедшего массива (циклом for)
        // и сделать так, чтобы поле класса (this.coord) указывало на эту новую копию массива,
        // а не на пришедший в аргументы массив:
        this.coord = new int[coord.length];//полю класса присваивается новый только-что созданный массив
        for (int i = 0; i < coord.length; i++) {//и далее в этот только-что созданный массив копируем тот, который пришел в аргументах
            this.coord[i] = coord[i];
            //помойму, это называют низкоуровневым копированием
            //в результате таких действий полю неизменяемого объекта будет присвоен не пришедший в аргументы массив
            //а его копия, и ссылка ----private final int[] coord;--- останется единственным хозяином массива
            //без этих действий в другом классе(из которого пришло сообщение) будет вторая ссылка на этот массив- а так нельзя
            //тк в другом классе можно будет по этой ссылке изменить содержимое массива
        }
    }

    //конструктор без аргументов для дефолтной инициализации объекта:
    public ImmutablePoint() {
        this.coord = new int[2];
    }

    //Если нужно вернуть значение поля ссылки. То нужно создать копию объекта по
    //ссылке и вернуть ссылку на новый объект, чтобы избежать утечки ссылки в другой класс, в котором можно
    // будет изменить содержимое массива, а след и состояние неизменяемого объекта
    public final int[] getCoord() {//Возврат копии объекта, на который указывает поле
        int[] tempCoord = new int[coord.length];//создаем новый массив tempCoord[] такого же размера, как и запрашиваемый
        for (int i = 0; i < tempCoord.length; i++) {//копируем в него содержимое массива поля класса
            tempCoord[i] = this.coord[i];
        }
        return tempCoord;//и возвращаем этот склонированный массив- то единственная ссылка на массив останется только
        // в этом классе. если бы ссылка утекла в другой класс, то там можно было бы изменить состояние неизменяемого объекта
    }

    //то состояние объекта этого класса (в нем поле- это ссылка на другой объект-массив)) инициализируется один раз при его создании
    //и благодаря тому, что этот класс общается с другими через клоны этого массива, изменить первоначальное
    // состояние объекта не получится. Это полезно для многопоточности. такие объекты не требуют синхронизации.
    @
            Override
    public String toString() {
        return "ImmutablePoint [coord=" + Arrays.toString(coord) + "]";
    }
}

/**
        *  ......Это означает, что в конструкторе не стоит добавлять ссылку this в ту или иную
        * коллекцию, регистрировать в той или иной службе и так далее.(те коллекции не инициализировать в конструкторе???)
        *   Работа со ссылками. Всегда нужно быть уверенным, что класс является
        * единственным «владельцем» объекта по ссылке, используемой в качестве поля. Это
        * налагает такие ограничения:
        * ● Если ссылка инициализируется в конструкторе. Нужно создать копию объекта,
        * ссылку на который получает конструктор. Поле должно указывать на эту новую
        * копию.
        * ● Если нужно вернуть значение поля ссылки. То нужно создать копию объекта по
        * ссылке и вернуть ссылку на новый объект.
        */

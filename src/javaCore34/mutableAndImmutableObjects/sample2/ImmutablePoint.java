package javaCore34.mutableAndImmutableObjects.sample2;

//Пример класса для создания неизменяемых объектов
public final class ImmutablePoint {

    private final double x;
    private final double y;

    public ImmutablePoint(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public ImmutablePoint() {
        this.x = 0;
        this.y = 0;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }


    //--------------------------------------------------------------------------------------------------------------
    //Пример методов установки для «изменения» неизменяемого объекта(в простом варианте без сетторов класс):
    //
    //этот Сеттер не изменит поле неизменяемого объекта, а вернет новый объект (с измененным полем)
    //состояние которого инициализируется на основе состояния текущего объекта.
    public ImmutablePoint setX(double x) {
        return new ImmutablePoint(x, y);
    }
    public ImmutablePoint setY(double y) {
        return new ImmutablePoint(x, y);
    }

    //--------------------------------------------------------------------------------------------------------------


    @Override
    public String toString() {
        return "ImmuatablePoint [x=" + x + ", y=" + y + "]";
    }
}

/**
 * Immutable (изменяемые)неизменяемые) объекты – объекты, состояние которых не может быть
 * изменено после создания.
 * Преимущества неизменяемых типов:
 * ● Легко конструировать, тестировать и использовать
 * ● Автоматически потокобезопасны и не имеют проблем синхронизации
 * ● Позволяют выполнить «ленивую инициализацию» хэшкода и кэшировать
 * возвращаемое значение
 * ● Корректно используются в качестве ключей в Map (эти объекты не должны
 * менять состояние, когда находятся в коллекции)
 * ● Всегда имеют «атомарность по отношению к сбою». Если неизменяемый объект
 * бросает исключение, он никогда не останется в нежелательном или
 * неопределенном состоянии
 * Недостатки:
 * ● Медленная работа при «изменении» состояния
 * ● Повышенное потребление памяти
 *
 * Рекомендации по созданию класса, описывающего
 * неизменяемые объекты:
 * 1)Все его поля являются final, методы установки требуют особого написания
 * 2)Класс объявляется как final
 * 3)Ссылка this не должна «убежать» во время конструирования
 * 4)Любые поля, содержащие ссылки на изменяемые объекты, например массивы,
 * коллекции или изменяемые классы:
 * ● Являются приватными
 * ● Никогда не возвращаются и никаким другим образом не становятся доступными
 * вызывающим операторам
 * ● Являются единственными ссылками на те объекты, на которые они ссылаются
 * ● Не изменяют после конструирования состояние объектов, на которые они
 * ссылаются
 *
 *   Объяснение некоторых моментов рекомендации по
 * созданию класса для неизменяемых объектов:
 * Работа с методами установки. В самом простом случае методов установки для
 * полей вообще не должно быть. Однако иногда нужно реализовать функционал, который
 * обеспечивает «изменение» неизменяемых объектов. На самом деле, это сведется к
 * созданию нового объекта на основании состояния текущего объекта плюс измененные
 * поля. В таком случае методы установки должны создавать новый объект и возвращать
 * его.
 *   Побег ссылки this на этапе конструирования - использование ссылки this в
 * конструкторе класса до окончания его работы(работы конструктора). Объект находится в предсказуемом и
 * согласованном состоянии только после возврата из конструктора, поэтому публикация
 * объекта из конструктора может привести к публикации не полностью построенного
 * объекта. Это справедливо, даже если публикация выполняется последним выражением в
 * конструкторе. Если ссылка на this сбегает в процессе построения, объект считается
 * построенным неправильно.
 * Это означает, что в конструкторе не стоит добавлять ссылку this в ту или иную
 * коллекцию, регистрировать в той или иной службе и так далее.(те коллекции не инициализировать в конструкторе???)
 *   Работа со ссылками. Всегда нужно быть уверенным, что класс является
 * единственным «владельцем» объекта по ссылке, используемой в качестве поля. Это
 * налагает такие ограничения:
 * ● Если ссылка инициализируется в конструкторе. Нужно создать копию объекта,
 * ссылку на который получает конструктор. Поле должно указывать на эту новую
 * копию.
 * ● Если нужно вернуть значение поля ссылки. То нужно создать копию объекта по
 * ссылке и вернуть ссылку на новый объект.
 */

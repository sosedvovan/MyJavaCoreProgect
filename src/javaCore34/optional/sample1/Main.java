/**
 *                              Класс Optional:
 * Optional - новый класс в пакете java.util, является контейнером (оберткой) для
 * значений которая также может безопасно содержать null. Впервые появился в Java 1.8.
 * Используется для уменьшения объемов кода и увеличения надежности при работе с null.
 *
 *             Какой класс задач решается с помощью Optional:
 * Класс Optional применяется в тех случаях когда из метода может быть возвращена
 * ссылка значение которой равно null и это в последствии может привести к
 * NullPointerException. Классическим примером подобного подхода является задача
 * поиска. В случае успеха возвращается ссылка на найденный объект. Но возникает
 * вопрос что вернуть в случае неудачи поиска. Обычно использовали два подхода:
 * ● Возврат null с последующей проверкой в коде.
 * ● Генерация исключения с последующим перехватом и обработкой.
 * Optional является классом оболочкой для возвращаемой из такого метода ссылки. И
 * работа с ним значительно облегчает обработку подобных ситуаций
 *
 *                  Пример метода для поиска с возвратом null, без использования Optional:
 *         public static Cat findCatByName(String name, Cat[] cats) {
 *         for (Cat cat : cats) {
 *         if (cat.getName().equals(name)) {
 *         return cat;
 *         }
 *         } return null;
 *         }
 * В примере показан метод который производит поиск объекта класса Cat в массиве
 * подобных объектов. В случае неудачи метод возвращает null. В таком случае нужны будут
 * дополнительные проверки значения возвращенной ссылки.
 *
 *                Пример метода поиска с генерацией исключения, без использования Optional:
 *         public static Cat findByNameEx(String name, Cat[] cats) throws NoSuchElementException {
 *         for (Cat cat : cats) {
 *         if (cat.getName().equals(name)) {
 *         return cat;
 *         }
 *         } throw new NoSuchElementException();
 *         }
 * В примере показан метод который производит поиск объекта класса Cat в массиве
 * подобных объектов. В случае неудачи метод генерирует исключение
 * NoSuchElementException. В вызывающем коде необходимо обрабатывать подобное
 * исключение.
 */

package javaCore34.optional.sample1;


import java.util.NoSuchElementException;
import java.util.Optional;

public class Main {

    public static void main(String[] args) {

        Cat cat1 = new Cat("Vaska", "Black");
        Cat cat2 = new Cat("Barsik", "Whit");
        Cat cat3 = new Cat("Umka", "Gray");

        Cat[] cats = new Cat[] {cat1, cat2, cat3};

        //       Статические методы класса Optional и их использование:

        //  У Optional есть ряд статических методов каждый из них используется для упаковки
        //  результата в следующих случаях. Все они возвращают Optional.
        //       Метод                     Когда использовать
        //Optional.empty()             Объект точно отсутствует
        //Optional.of(T obj)           Объект присутствует и он точно не null
        //Optional.ofNullable(T obj)  Объект присутствует, но возможно он null

        //Используемый вариант по большей мере определяется логикой метода. Указанное
        //выше не более чем рекомендация.


        //        Какие преимущества дает применение Optional:
        //Возврат значения типа Optional упрощает решения проблем указанных выше. Так, как
        //теперь в качестве типа возвращаемого значения указан Optional то это сразу указывает на
        //то, что результат поиска может быть и отрицательным. Теперь разработчику
        //использующему этот метод нужно будет в явном виде проверять наличие или отсутствие
        //результатов поиска. Таким образом код становиться яснее и безопаснее в использовании.


        //            Проверка наличия или отсутствия не null ссылки в Optional:

        //В простейшем случае для проверки наличия не null ссылки в Optional используется
        //метод isPresent() и если данные метод вернул true то хранимая ссылка не null и для ее
        //получения стоит вызвать метод get().

        //параметризированному объекту Optional<Cat> result - присваиваем Optional, который вернется из метода findCatByNameOptional
        //в нем будет или нуль или кошка
        Optional<Cat> result = findCatByNameOptional("Vaska", cats);
        //isPresent() вернет true, если в result не нуль
        if (result.isPresent()) {
            Cat cat = result.get();//если проверка пройденна и в result не нуль, присваиваем---get()---то, что лежит в result новому коту: Cat cat
            System.out.println(cat);
        }else {
            System.out.println("Cat not found");//если в result лежит нуль, то выведем это сообщение- таким образом мы обработали
            //возврат нуля из метода и не получили нульпоинтерэксепшен
        }
            //Если не выполнить проверку и вызвать метод get() и при этом ссылка в Optional равна
            //null будет создано исключение NoSuchElementException.


        //                Возврат значения по умолчанию:  (если в Optional оказался нуль)

        //Как вы уже убедились получение значения ссылки Optional довольно простое. Для
        //этого нужно использовать метод get(). В ряде случаев возникает потребность извлечь
        //ссылку на объект по умолчанию, если ссылка в Optional равна null. Вы можете вернуть
        //ссылку или уже на существующий объект, или сначала создать объект а потом его
        //вернуть.

        //                   Метод                                                       Когда использовать
        //T orElse (T other)                                             Если значение ссылки равно null и нужно вернуть ссылку
        //                                                               на существующий объект по умолчанию
        //
        //T orElseGet (Supplier<? extends T> javaCore34.supplier)                   Если значение ссылки равно null и нужно сначала
        //                                                               создать объект по умолчанию и потом вернуть ссылку на
        //                                                               него

        //                             Пример использования orElse: (дефолтный объект создан зареннее)

        //создадим объект кота, кот будет использаваться по умолчанию-дефолтно, если результат поиска вернет нуль
        Cat defaultCat = new Cat("Default name", "Default color");
        //объекту Optional<Cat> result2 присвоим опшинал, который вернется из метода поиска findCatByNameOptional
        Optional<Cat> result2 = findCatByNameOptional("Vaska", cats);
        //Cat cat22 присвоим кота из Optional<Cat> result2, а если там нуль,то присвоим дефолтного кота
        Cat cat22 = result2.orElse(defaultCat);
        System.out.println(cat22);
        //Теперь в случае неудачного поиска (т. е. если ссылка хранимая в Optional равна null)
        //метод orElse вернет ссылку которая использовалась в качестве его параметра. Т.е. ссылка
        //cat в случае успешного поиска будет указывать на найденный объект, а в случае неудачи
        //на объект по умолчанию(который создан до этого) (на него указывает ссылка defaultCat).


        //               Пример использования orElseGet:  (дефолтный объект создается по требованию))

        // в result3 присваиваем то, что пришло из метода поиска котов
        Optional<Cat> result3 = findCatByNameOptional("Vaska", cats);
        //если в result3 объект кота, то присваиваем его в Cat getCat, если в result3 нуль, то создаем пустой
        //объект кота(обратившись к пустому конструктору) и присваиваем этого пустого кота в Cat getCat
        Cat getCat = result3.orElseGet(Cat::new);
        //В случае неудачного поиска (т. е. если ссылка хранимая в Optional равна null) метод
        //orElseGet запустит процесс генерации объекта (в примере использована ссылка на
        //конструктор по умолчанию класс Cat) и вернет ссылку на него. Т.е. ссылка cat в случае
        //успешного поиска будет указывать на найденный объект, а в случае неудачи на объект по
        //умолчанию (был создан вызовом конструктора по умолчанию).


        //            Генерация исключения в случае «пустого» Optional:
        //При работе с кодом написанным ранее (т.е. до введения Optional) может оказаться,
        //что основные методы требуют результаты работы метода в виде ссылки. Если она равна
        //null то должна происходить генерация исключения. По сути если унаследованный код
        //опирается на прием когда в случае неудачного поиска или отсутствия объекта нужно
        //генерировать исключение то это можно выполнить с помощью следующих методов:

        //     Метод                                             Версия Java           Когда использовать
        //orElseThrow(Supplier<? extends X> exceptionSupplier)
        //                                                          1.8         Если храниться null то генерировать исключение
        //                                                                      полученное с помощью параметра метода.

        //orElseThrow()                                             1.11        Если храниться null то генерировать исключение
        //                                                                      NoSuchElementException

        //       Пример использования orElseThrow(Supplier<? extends X> exceptionSupplier):

        //Этот метод позволяет сгенерировать вам любое исключение в случае если в Optional
        //храниться null. Ссылку на конструктор этого исключения нужно указать в качестве
        //параметра этого метода. Правда стоит отметить, что чаще всего в таких случаях
        //генерируют NoSuchElementException.

        //// в result3 присваиваем то, что пришло из метода поиска котов
        Optional<Cat> result4 = findCatByNameOptional("Vaska", cats);
        //в Cat cat присвоится кот из опшинала, или-если в опшинале нуль, -генерируем ексепшн
        Cat cat4 = result4.orElseThrow(NoSuchElementException::new);//Ссылка на конструктор нужного исключения
        System.out.println(cat4);


        //            Пример использования orElseThrow():
        //По причине того что NoSuchElementException является наиболее часто генерируемым
        //исключением в Java 11 появился метод упрощающий этот процесс. Теперь если вызвать
        //orElseThrow() без параметров, то будет сгенерированно именно это исключение.

        Optional<Cat> result5 = findCatByNameOptional("Vaska", cats);
        Cat resultCat5 = result5.orElseThrow();//Получение ссылки или генерация исключения
        System.out.println(resultCat5);
        //При таком применении если ссылка в Optional не равна null то она будет извлечена и
        //присвоена ссылке resultCat. В противном случае будет возбужденно исключение
        //NoSuchElementException.


        //           Использование Optional для преобразования значений:

        //Когда на основе искомых объектов нужно создать новые данные можно использовать
        //методы трансформации Optional. Но перед их изучением сначала стоит рассмотреть что
        //значит генерация новых данных на основании получаемого объекта.

        Optional<Cat> result6 = findCatByNameOptional("Vaska", cats);
        Cat cat = result6.get();
        String catName = cat.getName();//Получение новых данных на основании полученного объекта
        //На основании искомого объекта класса Cat созданы новые данные в виде строки.

        //           Использование Optional для преобразования значений:

        //Для упрощения реализаций задачи подобной описанной выше стоит использовать
        //следующие методы Optional:

        //                     Метод                                            Когда использовать

        //Optional<T> filter (Predicate<? super T> javaCore34.predicate)
        //                                                               Если реализация Predicate вернет true, то вернеться
        //                                                               Optional со значением, в противном случае Optional со
        //                                                               значением null.

        //Optional<U> map (Function<? super T, ? extends U> mapper)
        //                                                               Если значение ссылки в Optional не равно null то
        //                                                               создается новый Optional на основании значения
        //                                                               ссылки. В противном случае вернется пустой Optional.

        //Optional<U> flatMap (Function<? super T, ? extends Optional<? extends U>> mapper)
        //                                                              Если значение ссылки в Optional не равно null то
        //                                                              создается новый Optional на основание текущего
        //                                                              Optional. В противном случае вернется пустой Optional.

        //Optional<T> or (Supplier<? extends Optional<? extends T>> javaCore34.supplier)
        //                                                              Если значение ссылки в Optional равно null то вернется
        //                                                              новый Optional созданный на основе параметра.

        //                             ДАЛЕЕ РАССМОТРИМ ЭТИ 4 МЕТОДА:

        //                          Пример использования метода map(функция):

        //положили в Optional<Cat> result7 кота, которого нашли с пом метода findCatByNameOptional, который возвращ объект Optional
        Optional<Cat> result7 = findCatByNameOptional("Vaska", cats);
        //но сейчас мы не хотим получить объект кота, а хотим получить строку с его именем(хотим получить измененные данные)
        //для этого воспользуемся методом map, в параметрах которого реализация функционального интерфейса Function
        //где с пом лямбды объект кота преобразуется в объект Стринг и кладется в новый Optional + ему говорим .get() тк стринге даем из опшионала
        String catColor = result7.map(a -> a.getName()).get();
        //если в опшионале нуль, выбрасывается NoSuchElementException, но можно добавить паровозиком дефолт строку: orElseGet(String::new)
        System.out.println("catColor: " + catColor);

        //В этом примере мы получаем Optional<Cat> в качестве результата поиска. В
        //дальнейшем при вызове метода map происходит создание Optional<String>. В качестве
        //параметра методу map передана лямбда функция которая используется в качестве
        //реализации функционального интерфейса Function и создает строку на основании объекта
        //класса Cat. Полученная строка пакуется в Optional. Т.е. метод map на основе одного
        //Optional генерирует другой Optional.


        //                   Пример использования метода or(супплер):

        //имеется массив строк
        String[] names = new String[] { null, null, "Vaska", null, "Barsik" };
        //в Optional<String> result8 положим первый элемент массива, кот может быть нуль, а может быть и не нуль (вспоминаем ofNullable() выше по тексту)
        Optional<String> result8 = Optional.ofNullable(names[0]);

        for (String n : names) {//итерируем массив
            //в цикле- создается новый Optional<String> temp, в него кладется текущий элемент цикла
            Optional<String> temp = Optional.ofNullable(n);

            //если текущий элемент нуль, то в result8 вернется новый Optional созданный на основе аргумента метода or() -
            //а в его аргументах реализован Supplier, те если текущий элемент цикла - нуль, то в result8 присваив текущю элемент (temp), те нуль
            //а если в temp попал текущий элемент НЕ НУЛЬ, тогда temp присваивается к result8
            result8 = result8.or(() -> temp);
            //МОЁ ОБЪЯСНЕНИЕ происходящего в цикле (помним что первоначально в result8 имеется нуль)
            //при 1-ой итерации в temp попадает нуль, а тк в result8 уже нуль первоначально лежит,
            // то срабатывает or() и присваевает в result8 опять нуль из temp'а
            //при 2-ой итерации происходит тоже самое, тк второй элемент массива тоже нуль
            //при 3-ей итерации в temp попадает строка "Vaska", но тк в result8 до сих пор лежит нуль- то опять
            //срабатывает or() и кладет в result8 "Vaska"у
            //при 4-ой итерации и далее or() не срабатывает, тк в result8 уже есть объект "Vaska"
            //то мы нашли первый не нуль элемент в массиве
        }
        System.out.println(result8.get());
        //Тут реализована идея поиска первого элемента массива не равного null и упаковку его
        //в новый Optional. Метод or работает следующим образом если в result8 храниться null, а
        //temp при этом не null, то result8 будет равен текущему temp. Остальные значения при этом
        //пропустяться.



        //                     Пример использования filter(предикат):

        String[] names2 = new String[] {null, null, "Vaska", null, "Barsik" };
        //дальнейшая логика будет работать если первым элементом массива являетс нуль, тк он присваивается опшиону result9.
        //если там не нуль, то в цикле for метод or() никогда не сработает и sout выведет этот же первый элемент присвоенный result9 первоначально.
        Optional<String> result9 = Optional.ofNullable(names2[0]);
        for (String n : names2) {
            //Опшиону temp2 присвоится новый опшионал с объектом внутри, этот опшионал создастся, если выполнится условие предиката в методе filter.
            //в данном случае метод ofNullable положит в опшионал обект, если предикат в аргументах метода filter вернет true, иначе положит нуль
            Optional<String> temp2 = Optional.ofNullable(n).filter(a -> a.startsWith("B"));//Проверка на то, что элемент начинается с «B»
            result9 = result9.or(() -> temp2);
        }
        System.out.println(result9.get());
        //Метод filter вызывается в случае если содержимое Optional не равно null. Если
        //реализация Predicate вернет true то будет возвращен Optional с этим элементом. В
        //примере в качестве реализации Predicate использована лямбда функция. Так как
        //элементом Optional является String то эта реализация вернет true только в случае если эта
        //строка начинается на «B».



        //                Пример использования flatMap(фанкшинал)

        String[] names3 = new String[] { null, null, "Vaska", null, "Barsik" };
        Optional<String> result11 = Optional.ofNullable(names3[0]);
        for (String n : names3) {
            //если в переменной n цикла будет не нуль, сработает метод flatMap, кот вернет новый опшионал, предварительно изменив этот объект(toUpperCase)
            Optional<String> temp3 = Optional.ofNullable(n).flatMap(a -> Optional.of(a.toUpperCase()));
            //пока в result11 лежит нуль- метод or срабатывает, как только temp3 принесет не нуль-объект, or() не будет срабатывать
            //то мы нашли первый не нуль объект в массиве и изменили его
            result11 = result11.or(() -> temp3);
        } System.out.println(result11.get());

        //В этом примере мы получаем Optional<String> в качестве результата поиска первого
        //отличного от null значения в массиве. После чего метод flatMap создает новый Optional
        //куда пакует значение строки в верхнем регистре.

        //               В чем разница между map и flatMap:
        //Довольно проблематично отличить разницу между методами map и flatMap ведь оба
        //возвращают Optional. Разница заключается в том:
        //● map — на основе значения генерирует новое значение. Стоит использовать когда
        //нужно сослаться на метод который принимает значение и возвращает значение.
        //● flatMap — на основе значения генерируется новый Optional со значением. Стоит
        //использовать когда нужно сослаться на метод который принимает значение и
        //возвращает Optional со значением.
        //По сути метод map для работы с кодом в котором не используется Optional, flatMap     !!!!!!!!!!!!!!!!
        //для работы с кодом в котором методы его активно используют.                           !!!!!!!!!!!!!!!!

        //в след sample смотри про эту разницу более подробно с примером в коде.

    }//закрыли главный метод


    //            Использование Optional:
    //В примере показан метод который производит поиск объекта класса Cat в массиве
    //подобных объектов. В качестве возвращаемого значения используется Optional<Cat>.
    //Именно в него «упаковывается» результат который и был возвращен.
    //на входе-искомое имя и сам массив
    public static Optional<Cat> findCatByNameOptional(String name, Cat[] cats) {
        //первоначально создаем ссылку Cat result на null
        Cat result = null;
        //если в цикле находим требуемого кота, тогда присваиваем его ссылке result
        for (Cat cat : cats) {
            if (cat.getName().equals(name)) {
                result = cat;
                break;
            }
        } return Optional.ofNullable(result);//возращается или найденный кот или null
    }

}//закрыли главный класс
